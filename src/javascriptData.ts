import type { TopicCategory } from './types';

export const javascriptTopics: TopicCategory[] = [
  {
    title: 'Core Fundamentals',
    topics: {
      'var-vs-let-vs-const': {
        title: 'var vs. let vs. const',
        content: '### var vs. let vs. const\n\nThese are three keywords used to declare variables in JavaScript. Their main differences are **scope**, **re-assignment**, and **hoisting**. Modern JavaScript favors `let` and `const`.\n\n| Feature | `var` | `let` | `const` |\n| :--- | :--- | :--- | :--- |\n| **Scope** | Function-scoped | Block-scoped `{}` | Block-scoped `{}` |\n| **Re-assignable**| Yes | Yes | **No** |\n| **Re-declarable**| Yes | **No** | **No** |\n| **Hoisting** | Hoisted and initialized with `undefined` | Hoisted but not initialized | Hoisted but not initialized |\n\n---\n\n#### 1. Scope: The Biggest Difference\n\n*   **`var`** is **function-scoped**. It is only contained within a function, even if declared inside a smaller block like a `for` loop or `if` statement. This can lead to unexpected behavior.\n*   **`let`** and **`const`** are **block-scoped**. They are only accessible within the block (the `{ }`) they are defined in, which is more predictable and less error-prone.\n\n**Example:**\n```javascript\nfunction scopeTest() {\n  if (true) {\n    var varVariable = "I am var";      // Leaks out to the whole function\n    let letVariable = "I am let";      // Stays inside this if-block\n    const constVariable = "I am const";// Stays inside this if-block\n  }\n  console.log(varVariable);     // "I am var"\n  // console.log(letVariable);  // Throws ReferenceError: not defined\n  // console.log(constVariable);// Throws ReferenceError: not defined\n}\n```\n\n---\n\n#### 2. Re-assignment and Re-declaration\n\n*   **`var`**: You can re-declare and update `var` variables.\n*   **`let`**: You can update the value, but you **cannot** re-declare it in the same scope.\n*   **`const`**: You **cannot** re-declare or re-assign it. It must be given a value when declared.\n    *   **Note:** For `const` objects and arrays, you can still change their internal content (properties or elements), but you cannot re-assign the variable to a new object or array.\n\n---\n\n#### 3. Hoisting\n\nHoisting is JavaScript\'s behavior of moving declarations to the top of their scope before code execution.\n\n*   **`var`**: Declarations are hoisted and initialized with a value of `undefined`. You can access it before the declaration line without an error (you\'ll just get `undefined`).\n*   **`let`** and **`const`**: Declarations are hoisted but **not initialized**. Accessing them before the declaration line results in a `ReferenceError`. This area before the declaration is called the "Temporal Dead Zone" (TDZ).\n\n**Example:**\n```javascript\nconsole.log(myVar); // undefined\nvar myVar = 5;\n\n// console.log(myLet); // Throws ReferenceError: Cannot access \'myLet\' before initialization\nlet myLet = 10;\n```\n\n---\n\n### Best Practice\n\n*   Use **`const`** by default.\n*   Use **`let`** only when you know you need to re-assign the variable\'s value.\n*   Avoid using **`var`** in modern JavaScript.'
      },
      'this-keyword': {
        title: 'The this Keyword',
        content: '### The `this` Keyword\n\nThe `this` keyword is a reference to the **execution context** of a function. Its value is not static; it is determined by *how the function is called*.\n\n---\n\n#### `this` in a Regular Function (Dynamic Context)\n\nThe value of `this` is determined at the moment the function is invoked. There are four main rules:\n\n1.  **As a Method of an Object:** When a function is called as a method on an object, `this` refers to the **object** the method was called on.\n    ```javascript\n    const person = {\n      name: \'Ibrahem\',\n      greet: function() {\n        console.log(`Hello, my name is ${this.name}`);\n      }\n    };\n\n    person.greet(); // `this` is the `person` object. Logs: "Hello, my name is Ibrahem"\n    ```\n\n2.  **As a Standalone Function:** When a function is called by itself (not as an object method), `this` defaults to the **global object** (`window` in browsers, `global` in Node.js). In strict mode, it is `undefined`.\n    ```javascript\n    function showThis() {\n      console.log(this);\n    }\n\n    showThis(); // `this` is the `window` object (in a browser)\n    ```\n\n3.  **As a Constructor:** When a function is used as a constructor with the `new` keyword, `this` refers to the **new instance** being created.\n    ```javascript\n    function Car(brand) {\n      this.brand = brand;\n    }\n\n    const myCar = new Car(\'Ford\');\n    console.log(myCar.brand); // `this` inside Car referred to `myCar`. Logs: "Ford"\n    ```\n\n4.  **Explicitly Set:** You can manually set the value of `this` using `.call()`, `.apply()`, or `.bind()`.\n\n---\n\n#### `this` in an Arrow Function (Lexical Context)\n\nArrow functions do not have their own `this` context. Instead, they **inherit `this` from their parent scope** at the time they are defined. The value of `this` inside an arrow function is determined by its surrounding code and remains fixed.\n\nThis behavior is especially useful for callbacks inside methods.\n\n**Example: Regular vs. Arrow Function Callback**\n```javascript\nconst user = {\n  name: \'John\',\n  scores: [90, 85, 95],\n\n  // Using a regular function for the callback\n  calculateAverage_Regular: function() {\n    setTimeout(function() {\n      // `this` here is the `window` object, because setTimeout is a window method.\n      // `this.name` is undefined, causing a bug.\n      console.log(`Average for ${this.name} is... WRONG!`); // "Average for undefined is... WRONG!"\n    }, 500);\n  },\n\n  // Using an arrow function for the callback\n  calculateAverage_Arrow: function() {\n    setTimeout(() => {\n      // The arrow function inherits `this` from its parent, `calculateAverage_Arrow`.\n      // In that context, `this` is the `user` object.\n      const avg = this.scores.reduce((a, b) => a + b) / this.scores.length;\n      console.log(`Average for ${this.name} is ${avg}`); // "Average for John is 90"\n    }, 1000);\n  }\n};\n\nuser.calculateAverage_Regular();\nuser.calculateAverage_Arrow();\n```\n\n---\n\n### Summary\n\n| Function Type | How `this` is Determined |\n| :--- | :--- |\n| **Regular Function** | **Dynamically** - Depends on *how it\'s called*. |\n| **Arrow Function** | **Lexically** - Inherits from the *parent scope where it was defined*. |'
      },
      'data-types': {
        title: 'Data Types: Primitives vs. Objects',
        content: '### Data Types: Primitives vs. Objects\n\nIn JavaScript, all data types are divided into two main categories: **Primitive Types** and **Object (or Reference) Types**. The fundamental difference between them is how they are stored in memory and how they are passed around in your code.\n\n---\n\n#### Primitive Types\n\nPrimitives are the most basic data types. They are **immutable**, meaning their value cannot be changed once created. Any operation that seems to modify a primitive actually creates a new one.\n\nThere are 7 primitive types:\n*   `string`\n*   `number`\n*   `boolean`\n*   `null`\n*   `undefined`\n*   `symbol`\n*   `bigint`\n\n**Key Behavior: Passed by Value**\n\nWhen you assign a primitive variable to another variable, a **copy** of the value is made. They are completely independent.\n\n```javascript\n// Passed by Value\nlet a = 100;\nlet b = a; // A copy of the value 100 is assigned to b.\n\nconsole.log(a); // 100\nconsole.log(b); // 100\n\n// Now, let\'s change b\nb = 200;\n\nconsole.log(a); // 100 (a is completely unaffected)\nconsole.log(b); // 200\n```\n\n---\n\n#### Object (Reference) Types\n\nObjects are more complex data structures. This category includes `Object`, `Array`, `Function`, `Date`, etc. They are **mutable**, meaning their internal state or properties can be changed.\n\n**Key Behavior: Passed by Reference**\n\nWhen you assign an object variable to another, you are not copying the object itself. Instead, you are copying the **reference** (or the pointer) to the location of the object in memory. Both variables point to the exact same object.\n\n```javascript\n// Passed by Reference\nlet person1 = {\n  name: "Ibrahem",\n  age: 30\n};\n\n// A copy of the REFERENCE is made. Both variables point to the SAME object.\nlet person2 = person1;\n\nconsole.log(person1.name); // "Ibrahem"\nconsole.log(person2.name); // "Ibrahem"\n\n// Now, let\'s change a property using person2\nperson2.name = "Ali";\n\n// The change is reflected in BOTH variables because they point to the same object.\nconsole.log(person1.name); // "Ali" (person1 was also changed!)\nconsole.log(person2.name); // "Ali"\n```\n\nA common point of confusion is re-assignment. If you assign a completely new object to `person2`, you are only changing the reference for `person2`, which breaks the link to the original object.\n\n```javascript\nperson2 = { name: "Fatima", age: 25 }; // person2 now points to a new object\n\nconsole.log(person1.name); // "Ali" (person1 is unaffected by the re-assignment)\nconsole.log(person2.name); // "Fatima"\n```\n\n---\n\n### Summary\n\n| Characteristic | Primitive Types | Object (Reference) Types |\n| :--- | :--- | :--- |\n| **Storage** | Stored directly in the variable | Variable stores a reference (pointer) to the object\'s memory location |\n| **Assignment** | **Pass by Value** (a copy is made) | **Pass by Reference** (the pointer is copied) |\n| **Mutability** | **Immutable** (cannot be changed) | **Mutable** (properties can be changed) |\n| **Comparison (`===`)**| Compares the actual values | Compares if the references point to the same object in memory |'
      },
      'equality': {
        title: 'Equality: == vs. ===',
        content: '### Equality: `==` (Loose) vs. `===` (Strict)\n\nIn JavaScript, `==` and `===` are used to compare two values, but they do so in fundamentally different ways. The key difference is that `==` performs **type coercion**, while `===` does not.\n\n---\n\n#### `==` (Loose Equality)\n\nThe `==` operator compares two values for equality **after** converting both values to a common type. This is called type coercion. This can lead to unpredictable and often buggy results because the conversion rules are complex.\n\n**How it works:**\n1.  Are the types the same? If yes, compare the values (like `===`).\n2.  If the types are different, attempt to convert one or both values to a common type.\n3.  Compare the converted values.\n\n**Examples of unexpected behavior:**\n```javascript\n\'1\' == 1;         // true (string \'1\' is converted to number 1)\ntrue == 1;        // true (boolean true is converted to number 1)\nnull == undefined; // true (this is a specific rule in the spec)\n0 == false;       // true (boolean false is converted to number 0)\n\'\' == false;      // true (empty string is converted to number 0)\n[10] == 10;       // true (array is converted to string \'10\', then to number 10)\n```\nBecause of these automatic conversions, loose equality is often considered unsafe and is a common source of bugs.\n\n---\n\n#### `===` (Strict Equality)\n\nThe `===` operator compares two values for equality **without** performing any type conversion. It checks if both the **type** and the **value** are identical.\n\n**How it works:**\n1.  Are the types the same? If no, return `false`.\n2.  If the types are the same, are the values the same?\n    *   For primitives (number, string, boolean), it checks if the values are identical.\n    *   For objects (including arrays), it checks if the variables reference the **exact same object** in memory.\n\n**Examples:**\n```javascript\n\'1\' === 1;         // false (string vs. number)\ntrue === 1;        // false (boolean vs. number)\nnull === undefined; // false (null vs. undefined)\n0 === false;       // false (number vs. boolean)\n\nconst obj1 = {};\nconst obj2 = {};\nobj1 === obj2; // false (they are two different objects in memory)\n\nconst obj3 = obj1;\nobj1 === obj3; // true (they both reference the same object)\n```\n\n---\n\n### Best Practice\n\n**Always use `===` (Strict Equality).**\n\nIt is predictable, safe, and avoids the need to memorize JavaScript\'s complex type coercion rules. There are very few situations where `==` is genuinely useful (the most common argument is `variable == null`, which checks for both `null` and `undefined`, but this can also be confusing). Using `===` makes your code more robust and easier to understand.'
      },
      'type-coercion': {
        title: 'Type Coercion',
        content: '### Type Coercion\n\nType coercion is the automatic or implicit conversion of values from one data type to another by the JavaScript engine. This happens when you use operators on values of different types.\n\nWhile it can make the language feel flexible, it\'s also a major source of bugs if you don\'t understand its rules.\n\n---\n\n#### 1. Coercion to a String\n\nThis is the most common and straightforward type of coercion. When the `+` operator is used with a string and any other type, the other type is converted to a string.\n\n```javascript\n// The `+` operator triggers string coercion\n"Hello " + 42;          // "Hello 42"\n"5" + 5;                // "55" (not 10)\n"The result is " + true; // "The result is true"\n"items: " + [1, 2, 3];  // "items: 1,2,3"\n```\n\n---\n\n#### 2. Coercion to a Number\n\nNumeric coercion happens when an operator other than `+` is used with a value that can be converted to a number. This includes arithmetic operators (`-`, `*`, `/`, `%`) and comparison operators.\n\n```javascript\n// Arithmetic operators trigger number coercion\n\'10\' - 5;       // 5  (string \'10\' becomes number 10)\n\'100\' * \'2\';    // 200\n\'10\' > 5;       // true (string \'10\' becomes number 10)\n\n// Special cases\ntrue - 1;       // 0 (true becomes 1)\nfalse + 1;      // 1 (false becomes 0)\n\'five\' * 2;     // NaN (Not a Number), because \'five\' cannot be converted to a number\n```\nNote: `null` is coerced to `0`, while `undefined` is coerced to `NaN`.\n\n---\n\n#### 3. Coercion to a Boolean (Truthy and Falsy)\n\nBoolean coercion happens in logical contexts, such as an `if` statement or with logical operators (`&&`, `||`, `!`). Every value in JavaScript has an inherent "truthiness".\n\n**Falsy Values**\nThere are only a handful of values that are coerced to `false`. You should memorize these:\n\n*   `false`\n*   `0` (and `-0`)\n*   `""` (empty string)\n*   `null`\n*   `undefined`\n*   `NaN` (Not a Number)\n\n**Truthy Values**\nAny value that is not on the "falsy" list is considered **truthy**. This includes:\n\n*   `"hello"` (any non-empty string)\n*   `1` (any non-zero number)\n*   `[]` (an empty array)\n*   `{}` (an empty object)\n*   `function() {}` (any function)\n\n**Example:**\n```javascript\nif ("hello") {\n  // This code runs, because "hello" is truthy\n}\n\nif (0) {\n  // This code does NOT run, because 0 is falsy\n}\n\nconsole.log(!\'\');       // true (the opposite of the falsy empty string)\nconsole.log(!!\'hello\');  // true (a common way to explicitly coerce to a boolean)\n```\n\n---\n\n### Why It Matters\n\n*   **Loose Equality (`==`):** Type coercion is the reason `==` is unpredictable. It tries to convert types before comparing, leading to results like `\'1\' == 1`.\n*   **Bugs:** Unintended coercion can lead to silent errors. For example, getting `"5" + 5 = "55"` when you expected `10` from form inputs.\n\n**Best Practice:** Be aware that coercion exists. For clarity and safety, perform **explicit** type conversions (e.g., using `Number()`, `String()`, `Boolean()`) instead of relying on JavaScript\'s implicit rules.'
      }
    }
  },
  {
    title: 'Scope and Functions',
    topics: {
      'scope': {
        title: 'Scope: Global, Function, and Block',
        content: '### Scope: Global, Function, and Block\n\nScope in JavaScript determines the accessibility or visibility of variables. It is the context in which variables are declared and can be accessed. There are three main types of scope.\n\n---\n\n#### 1. Global Scope\n\nAny variable declared outside of a function or block belongs to the global scope. These variables are accessible from anywhere in your entire JavaScript program.\n\nDeclaring variables in the global scope is generally discouraged as it can lead to naming conflicts and make code harder to manage.\n\n```javascript\n// This variable is in the global scope\nconst globalVar = "I am accessible everywhere";\n\nfunction someFunction() {\n  console.log(globalVar); // Accessible inside the function\n}\n\nsomeFunction();\nconsole.log(globalVar); // Accessible outside the function as well\n```\n\n---\n\n#### 2. Function Scope\n\nVariables declared with `var` are **function-scoped**. This means they are accessible anywhere within the function they are declared in, regardless of the block (e.g., `if` statement or `for` loop) they are in.\n\n```javascript\nfunction myFunction() {\n  var functionScopedVar = "I am visible throughout the function";\n\n  if (true) {\n    console.log(functionScopedVar); // Accessible here\n  }\n}\n\nmyFunction();\n// console.log(functionScopedVar); // Throws ReferenceError: not defined (cannot be accessed outside the function)\n```\n\n**Hoisting within Function Scope:**\n`var` declarations are "hoisted" (lifted) to the top of their function scope, which is why you can access them before the line of declaration (though their value will be `undefined`).\n\n---\n\n#### 3. Block Scope\n\nIntroduced in ES6 with `let` and `const`, block scope limits a variable\'s accessibility to the specific block (`{ }`) in which it was declared. This is more predictable and helps prevent bugs caused by variables "leaking" out of their intended blocks.\n\nMost modern programming languages use block scope, and it is the preferred way to declare variables in JavaScript.\n\n```javascript\nfunction myBlockScopeFunction() {\n  if (true) {\n    let letVar = "I am a block-scoped let";\n    const constVar = "I am a block-scoped const";\n    var varVar = "I am function-scoped!"; // \'var\' is NOT block-scoped\n\n    console.log(letVar);   // Accessible here\n    console.log(constVar); // Accessible here\n    console.log(varVar);   // Accessible here\n  }\n\n  // console.log(letVar);   // Throws ReferenceError: not defined\n  // console.log(constVar); // Throws ReferenceError: not defined\n  console.log(varVar);   // "I am function-scoped!" -> var leaks out of the if-block\n}\n\nmyBlockScopeFunction();\n```\n\n---\n\n### Summary and Best Practice\n\n| Keyword | Scope | Hoisted? | Notes |\n| :--- | :--- | :--- | :--- |\n| **`var`** | **Function** | Yes (with `undefined`) | Avoid in modern JS. Leaks out of blocks. |\n| **`let`** | **Block** | Yes (but not initialized) | The preferred choice for variables that need to be reassigned. |\n| **`const`**| **Block** | Yes (but not initialized) | The preferred choice for all variables unless they need reassignment. |\n\nBy defaulting to `const` and using `let` only when necessary, you leverage the predictability and safety of block scope, making your code easier to read and maintain.'
      },
      'closures': {
        title: 'Closures',
        content: '### Closures\n\nA closure is a fundamental concept in JavaScript where a function **remembers the variables from the scope in which it was created**, even if that function is executed in a different scope.\n\nIn simple terms, a function and its connection to its outer scope\'s variables form a closure. This "connection" or "backpack" of variables persists even after the outer function has finished running.\n\n---\n\n#### How It Works: A Simple Example\n\n```javascript\nfunction createGreeter(greeting) {\n  const name = "Ibrahem"; // Variable in the outer scope\n\n  // This inner function is a closure.\n  // It "closes over" the `greeting` and `name` variables.\n  function greet() {\n    console.log(`${greeting}, ${name}!`);\n  }\n\n  return greet; // We return the inner function itself\n}\n\n// 1. We call the outer function. It runs and finishes.\nconst sayHello = createGreeter("Hello");\nconst sayHi = createGreeter("Hi");\n\n// 2. We are now calling the inner function, long after its parent has completed.\n//    Yet, it still remembers the variables from when it was created.\nsayHello(); // Logs: "Hello, Ibrahem!"\nsayHi();    // Logs: "Hi, Ibrahem!"\n```\n\nIn this example, the `greet` function maintains a reference to its lexical environment, which includes the `greeting` and `name` variables. Even when `createGreeter` is done, `greet` (now assigned to `sayHello` and `sayHi`) carries its "backpack" of variables with it.\n\n---\n\n#### Practical Use Cases for Closures\n\nClosures are not just a theoretical concept; they are used constantly in JavaScript programming.\n\n**1. Data Privacy and Encapsulation (The Module Pattern)**\n\nClosures are the primary way to create private variables in JavaScript. You can expose a public interface (a set of functions) that can interact with the private internal state, but the state itself cannot be accessed directly from the outside.\n\n```javascript\nfunction createCounter() {\n  let count = 0; // This variable is private to the closure\n\n  // We return an object with methods that can access \'count\'\n  return {\n    increment: function() {\n      count++;\n      console.log(count);\n    },\n    decrement: function() {\n      count--;\n      console.log(count);\n    },\n    getCount: function() {\n      return count;\n    }\n  };\n}\n\nconst counter = createCounter();\ncounter.increment(); // 1\ncounter.increment(); // 2\n\n// You CANNOT access `count` directly from the outside.\n// console.log(counter.count); // undefined\n// This protects the internal state from accidental modification.\n\nconsole.log(`The current count is: ${counter.getCount()}`); // The current count is: 2\n```\n\n**2. Event Handlers and Callbacks**\n\nClosures are essential for callbacks, especially in loops, to capture the correct value at each iteration.\n\n**The Classic Loop Problem:**\nWithout a closure, a `setTimeout` inside a `for` loop with `var` will produce an unexpected result. All the callbacks will reference the *final* value of `i`.\n\n```javascript\nfor (var i = 1; i <= 3; i++) {\n  setTimeout(function() {\n    // By the time this runs, the loop is finished and `i` is 4.\n    console.log(i); // Logs 4, 4, 4\n  }, 100);\n}\n```\n**The Modern Solution (`let`):**\nUsing `let` instead of `var` solves this problem automatically. `let` is block-scoped, so it creates a new binding of `i` for each loop iteration, effectively creating a closure for each `setTimeout` callback.\n\n```javascript\nfor (let i = 1; i <= 3; i++) {\n  setTimeout(function() {\n    // `let` creates a new `i` for each iteration.\n    // The callback closes over this new `i`.\n    console.log(i); // Logs 1, then 2, then 3\n  }, 100);\n}\n```'
      },
      'arrow-vs-regular-functions': {
        title: 'Arrow Functions vs. Regular Functions',
        content: '### Arrow Functions vs. Regular Functions\n\nWhile the behavior of the `this` keyword is the most significant difference, arrow functions and regular functions have several other distinctions in syntax and functionality.\n\n---\n\n#### Key Differences Summary\n\n| Feature | Regular Function | Arrow Function |\n| :--- | :--- | :--- |\n| **`this` Binding** | Dynamic (depends on call site) | Lexical (inherits from parent) |\n| **Syntax** | Verbose (`function` keyword, `{}`) | Concise (`=>`) |\n| **`arguments` Object**| Has its own `arguments` object | Does **not** have its own `arguments` |\n| **Constructor** | Can be used with `new` | **Cannot** be used with `new` |\n| **Implicit Return** | Requires `return` keyword | Can implicitly return if no block `{}` |\n\n---\n\n#### 1. Syntax\n\nArrow functions offer a much more compact syntax.\n\n```javascript\n// Regular Function Expression\nconst addRegular = function(a, b) {\n  return a + b;\n};\n\n// Arrow Function\nconst addArrow = (a, b) => a + b; // Implicit return (no curly braces)\n\n// Arrow function with a block (requires explicit return)\nconst addArrowWithBlock = (a, b) => {\n  console.log(`Adding ${a} and ${b}`);\n  return a + b;\n};\n```\n\n---\n\n#### 2. The `arguments` Object\n\nRegular functions have a special, array-like object named `arguments` that contains all the arguments passed to the function. Arrow functions do **not** have their own `arguments` object.\n\nTo capture all arguments in an arrow function, you should use **rest parameters (`...`)**.\n\n```javascript\n// Regular Function\nfunction logArgsRegular() {\n  console.log(arguments); // [1, 2, 3, "hello"] (an array-like arguments object)\n}\nlogArgsRegular(1, 2, 3, "hello");\n\n\n// Arrow Function\nconst logArgsArrow = (...args) => {\n  // console.log(arguments); // Throws ReferenceError: arguments is not defined\n  console.log(args);        // [1, 2, 3, "hello"] (a true array)\n};\nlogArgsArrow(1, 2, 3, "hello");\n```\nUsing rest parameters (`...args`) is the modern and preferred approach for both types of functions as it provides a true array, not just an array-like object.\n\n---\n\n#### 3. Usage as Constructors\n\nRegular functions can be used as constructors to create objects with the `new` keyword. Arrow functions **cannot** be used as constructors and will throw a `TypeError` if you try.\n\n```javascript\n// Regular Function as a constructor\nfunction Person(name) {\n  this.name = name;\n}\nconst ibrahem = new Person(\'Ibrahem\');\nconsole.log(ibrahem.name); // \'Ibrahem\'\n\n// Arrow Function as a constructor\nconst Animal = (name) => {\n  this.name = name;\n};\n// const dog = new Animal(\'Dog\'); // Throws TypeError: Animal is not a constructor\n```\n\n---\n\n### When to Use Each\n\n*   **Use an Arrow Function (`=>`) for:**\n    *   Most callbacks (`.map()`, `.filter()`, `setTimeout()`, etc.) where you want to preserve the `this` from the parent scope.\n    *   Short, non-method functions.\n\n*   **Use a Regular Function (`function`) for:**\n    *   **Object methods** when you need `this` to refer to the object itself.\n    *   **Constructors** for creating new instances with `new`.\n    *   Situations where you need the legacy `arguments` object (though rest parameters are better).'
      }
    }
  },
  {
    title: 'Asynchronous JavaScript',
    topics: {
      'event-loop': {
        title: 'The Event Loop',
        content: '### The Event Loop (Microtasks vs. Macrotasks)\n\nThe Event Loop is the core mechanism in JavaScript that allows it to handle asynchronous operations, like `setTimeout` or fetching data, without blocking the main thread. It\'s a constantly running process that manages the **Call Stack** and two important queues: the **Microtask Queue** and the **Macrotask Queue**.\n\n---\n\n#### Key Components\n\n1.  **Call Stack:** Where all synchronous code is executed. It operates on a "first in, last out" basis. When a script is run, its global context is pushed to the stack.\n2.  **Macrotask Queue (or Callback Queue):** A queue for lower-priority asynchronous tasks. The event loop picks **one** task from this queue per cycle.\n    *   Examples: `setTimeout`, `setInterval`, I/O operations (like file reading), UI rendering.\n3.  **Microtask Queue (or Job Queue):** A special, **higher-priority** queue. The event loop will run **all** tasks in this queue until it\'s empty before moving on.\n    *   Examples: Promise handlers (`.then()`, `.catch()`, `.finally()`), `queueMicrotask()`.\n\n---\n\n#### The Order of Operations\n\nThe event loop follows a strict order, which determines when different pieces of code will run.\n\n1.  **Run Synchronous Code:** First, all synchronous code in the current script is executed line by line on the Call Stack. Any async tasks encountered (`setTimeout`, `Promise`) are scheduled and their callbacks are sent to the appropriate queue.\n2.  **Execute All Microtasks:** After the Call Stack is empty, the event loop immediately checks the **Microtask Queue**. It will execute *every single task* in this queue until it is completely empty. If a microtask adds a new microtask, that new task is also executed in this same phase.\n3.  **Execute One Macrotask:** Only when the Microtask Queue is empty does the event loop check the **Macrotask Queue**. It takes just **one** task from this queue, pushes its callback onto the now-empty Call Stack, and executes it.\n4.  **Repeat:** After the macrotask is complete, the loop goes back to **Step 2** (checking for microtasks again) and repeats the cycle.\n\n**Analogy:** Think of microtasks as urgent, high-priority work you must finish immediately. Macrotasks are like regular, new tasks you can only start after all the urgent work is done.\n\n---\n\n#### Example Scenario\n\nThis is a classic interview question that demonstrates the concept:\n\n```javascript\nconsole.log(\'1: Script Start\'); // Sync\n\nsetTimeout(() => {\n  console.log(\'2: setTimeout (Macrotask)\'); // Sent to Macrotask Queue\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log(\'3: Promise 1 (Microtask)\'); // Sent to Microtask Queue\n  Promise.resolve().then(() => {\n    console.log(\'4: Promise 2 (Microtask)\'); // Also sent to Microtask Queue\n  });\n});\n\nconsole.log(\'5: Script End\'); // Sync\n```\n\n#### Predicted Output:\n\n1.  **`1: Script Start`** (Synchronous)\n2.  **`5: Script End`** (Synchronous)\n    *   The synchronous code finishes. Now the event loop checks the queues.\n3.  **`3: Promise 1 (Microtask)`**\n    *   The Microtask Queue is checked first and is not empty. This promise callback runs.\n4.  **`4: Promise 2 (Microtask)`**\n    *   While executing the first microtask, another microtask was added. The event loop must clear the *entire* microtask queue before moving on, so this one runs next.\n5.  **`2: setTimeout (Macrotask)`**\n    *   The Microtask Queue is finally empty. The event loop now picks one task from the Macrotask Queue and executes it.\n\n#### Final Log Order:\n```\n1: Script Start\n5: Script End\n3: Promise 1 (Microtask)\n4. Promise 2 (Microtask)\n2: setTimeout (Macrotask)\n```'
      },
      'promises': {
        title: 'Promises',
        content: '### Promises: `.then()`, `.catch()`, `.finally()`, and `Promise.all()`\n\nA `Promise` is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. It provides a cleaner, more robust way to handle asynchronous code than traditional callbacks.\n\n---\n\n#### The Three States of a Promise\n\nA Promise is always in one of three states:\n\n1.  **Pending:** The initial state; the asynchronous operation has not yet completed.\n2.  **Fulfilled (or Resolved):** The operation completed successfully, and the promise has a resulting value.\n3.  **Rejected:** The operation failed, and the promise has a reason for the failure (an error).\n\nA promise is **settled** when it is either fulfilled or rejected. It can only be settled once.\n\n---\n\n#### `.then(onFulfilled, onRejected)`\n\nThe `.then()` method is the primary way to interact with a promise. It takes up to two arguments: a callback function for the fulfilled state and another for the rejected state.\n\nIt returns a **new promise**, which is what allows for chaining.\n\n```javascript\nconst myPromise = new Promise((resolve, reject) => {\n  // Simulate an async operation\n  setTimeout(() => {\n    if (Math.random() > 0.5) {\n      resolve("Operation was successful!");\n    } else {\n      reject("Operation failed.");\n    }\n  }, 1000);\n});\n\nmyPromise.then(\n  (successMessage) => { // onFulfilled callback\n    console.log("Success:", successMessage);\n  },\n  (errorMessage) => { // onRejected callback (less common)\n    console.log("Error:", errorMessage);\n  }\n);\n```\n\n---\n\n#### `.catch(onRejected)`\n\nThe `.catch()` method is syntactic sugar for `.then(null, onRejected)`. It\'s a cleaner, more readable way to handle only the rejection case. It also returns a new promise, allowing you to continue chaining.\n\nUsing `.catch()` is the standard and preferred way to handle errors in a promise chain.\n\n```javascript\nmyPromise\n  .then((successMessage) => {\n    console.log(successMessage);\n    // You can return a value here to be passed to the next .then()\n    return successMessage.toUpperCase();\n  })\n  .then((uppercasedMessage) => {\n    console.log("Uppercased:", uppercasedMessage);\n  })\n  .catch((errorMessage) => {\n    // This will catch a rejection from myPromise or any preceding .then()\n    console.error("Caught an error:", errorMessage);\n  });\n```\n\n---\n\n#### `.finally(onFinally)`\n\nThe `.finally()` method schedules a function to be called when the promise is settled (either fulfilled or rejected). It is useful for cleanup operations that should happen regardless of the outcome, such as hiding a loading spinner.\n\nThe `.finally()` callback receives no arguments and does not affect the promise\'s final value.\n\n```javascript\nshowLoadingSpinner(); // Show spinner before the operation starts\n\nmyPromise\n  .then((result) => console.log(result))\n  .catch((error) => console.error(error))\n  .finally(() => {\n    // This code runs no matter what happens\n    hideLoadingSpinner();\n    console.log("Promise settled. Cleanup is done.");\n  });\n```\n\n---\n\n#### `Promise.all(iterable)`\n\n`Promise.all()` is a static method that takes an iterable (like an array) of promises and returns a single new promise.\n\n*   This new promise **fulfills** when **all** of the input promises have fulfilled. The fulfillment value is an array of the results from the input promises, in the same order.\n*   It **rejects** as soon as **any one** of the input promises rejects. The rejection reason is the reason from the first promise that rejected.\n\nThis is extremely useful for running multiple asynchronous operations in parallel and waiting for all of them to complete.\n\n```javascript\nconst promise1 = Promise.resolve("First");\nconst promise2 = new Promise(resolve => setTimeout(() => resolve("Second"), 500));\nconst promise3 = fetch(\'https://api.example.com/data\'); // Another promise\n\nPromise.all([promise1, promise2, promise3])\n  .then((results) => {\n    // results is an array: ["First", "Second", <Response Object>]\n    console.log("All promises fulfilled:", results);\n  })\n  .catch((error) => {\n    console.error("One of the promises rejected:", error);\n  });\n```'
      },
      'async-await': {
        title: 'async/await',
        content: '### `async/await`\n\n`async/await` is modern JavaScript syntax built on top of Promises that allows you to write asynchronous code as if it were synchronous. It makes complex asynchronous operations, like sequential API calls, much easier to read and manage.\n\n---\n\n#### The `async` Keyword\n\nWhen you place the `async` keyword before a function declaration, it does two things:\n\n1.  It ensures the function **always returns a promise**.\n2.  It allows the use of the `await` keyword inside that function.\n\nIf the function explicitly returns a value, that value will be the resolved value of the promise. If the function throws an error, the promise will be rejected with that error.\n\n```javascript\n// This function implicitly returns a promise that resolves with "Hello"\nasync function greet() {\n  return "Hello";\n}\n\ngreet().then(value => console.log(value)); // Logs: "Hello"\n\n// This function will return a rejected promise\nasync function fail() {\n  throw new Error("Something went wrong");\n}\n\nfail().catch(error => console.error(error.message)); // Logs: "Something went wrong"\n```\n\n---\n\n#### The `await` Keyword\n\nThe `await` keyword can **only be used inside an `async` function**. It tells the function to pause its execution at that line and wait for a promise to be settled.\n\n*   If the promise **fulfills**, `await` unwraps the promise and returns its resolved value.\n*   If the promise **rejects**, `await` throws the rejection reason as an error.\n\nThis is what makes the code look synchronous.\n\n**Example: Before (`.then()` chain) vs. After (`async/await`)**\n\nLet\'s imagine fetching a user and then fetching their posts.\n\n**Using `.then()`:**\n```javascript\nfunction fetchUserPostsWithThen() {\n  fetch(\'https://api.example.com/users/1\')\n    .then(response => response.json())\n    .then(user => {\n      return fetch(`https://api.example.com/posts?userId=${user.id}`);\n    })\n    .then(response => response.json())\n    .then(posts => {\n      console.log(posts);\n    })\n    .catch(error => {\n      console.error("Failed to fetch posts:", error);\n    });\n}\n```\n\n**Using `async/await`:**\nThe code is much more linear and readable.\n\n```javascript\nasync function fetchUserPostsWithAwait() {\n  try {\n    const userResponse = await fetch(\'https://api.example.com/users/1\');\n    const user = await userResponse.json();\n\n    const postsResponse = await fetch(`https://api.example.com/posts?userId=${user.id}`);\n    const posts = await postsResponse.json();\n\n    console.log(posts);\n  } catch (error) {\n    console.error("Failed to fetch posts:", error);\n  }\n}\n```\n\n---\n\n#### Error Handling with `try...catch`\n\nOne of the major benefits of `async/await` is that you can use standard `try...catch` blocks for error handling. This is often more intuitive and powerful than the `.catch()` method, as it allows you to handle errors from multiple `await` expressions in a single block.\n\nAs shown in the example above, the `try` block contains all the "happy path" logic, and the `catch` block will handle any rejection from any of the `await` calls within it.\n\n---\n\n### Summary\n\n| Aspect | `.then()` Chaining | `async/await` |\n| :--- | :--- | :--- |\n| **Readability** | Can become nested and hard to follow ("callback hell"). | Linear, sequential, and looks like synchronous code. |\n| **Error Handling** | Uses `.catch()` for each chain or at the end. | Uses standard `try...catch` blocks. |\n| **Debugging** | Can be difficult to step through asynchronous chains. | Easier to debug as you can step over `await` calls like regular lines of code. |\n\n**Best Practice:** Use `async/await` for most of your asynchronous logic as it leads to cleaner, more maintainable code.'
      }
    }
  },
  {
    title: 'Object-Oriented JavaScript',
    topics: {
      'prototypal-inheritance': {
        title: 'Prototypal Inheritance',
        content: '### Prototypal Inheritance\n\nPrototypal Inheritance is the core mechanism in JavaScript through which objects inherit properties and methods from other objects. Unlike class-based languages (like Java or C++), JavaScript\'s inheritance model is simpler: **objects inherit directly from other objects.**\n\n---\n\n#### The Prototype Chain\n\nEvery JavaScript object has a hidden internal property, `[[Prototype]]`, which is a reference (a link) to another object. This other object is called its **prototype**. That prototype object has its *own* prototype, and so on, until an object is reached with `null` as its prototype. This linked series of objects is called the **prototype chain**.\n\nWhen you try to access a property on an object, the JavaScript engine follows these steps:\n1.  It checks if the property exists directly on the object itself.\n2.  If not found, it follows the `[[Prototype]]` link to the next object in the chain and checks for the property there.\n3.  This process continues up the chain until the property is found or the end of the chain (`null`) is reached. If the property is never found, the result is `undefined`.\n\n`Object.prototype` is the base object at the top of almost every prototype chain. It provides common methods like `.toString()`, `.hasOwnProperty()`, etc.\n\n---\n\n#### How to Create Inheritance\n\nThere are three primary ways to set up the prototype chain.\n\n**1. `Object.create()` (The Modern Way)**\n\nThis is the most direct method. `Object.create(proto)` creates a new empty object whose `[[Prototype]]` is set to the `proto` object you provide.\n\n```javascript\n// 1. The prototype object (the object we want to inherit from)\nconst animal = {\n  eat: function() {\n    console.log("Eating...");\n  },\n  sleep: function() {\n    console.log("Sleeping...");\n  }\n};\n\n// 2. Create a new object that inherits from `animal`\nconst dog = Object.create(animal);\ndog.bark = function() {\n  console.log("Woof! Woof!");\n};\n\n// 3. Using the methods\ndog.eat();   // "Eating..." -> Found on the `animal` prototype\ndog.bark();  // "Woof! Woof!" -> Found directly on `dog`\n\n// Checking properties\nconsole.log(dog.hasOwnProperty(\'bark\')); // true (it\'s dog\'s own property)\nconsole.log(dog.hasOwnProperty(\'eat\'));  // false (it\'s an inherited property)\n```\n\n**2. Constructor Functions (The "Old" Way)**\n\nBefore ES6 classes, this was the standard way to mimic classes. When a function is called with the `new` keyword, the new object\'s `[[Prototype]]` is automatically linked to the constructor function\'s `.prototype` property.\n\n```javascript\n// Constructor function\nfunction Animal(name) {\n  this.name = name;\n}\n\n// Add methods to the constructor\'s prototype property\nAnimal.prototype.eat = function() {\n  console.log(`${this.name} is eating.`);\n};\n\n// `new` links the new object\'s prototype to Animal.prototype\nconst cat = new Animal(\'Whiskers\');\ncat.eat(); // "Whiskers is eating."\n```\n\n**3. ES6 `class` Syntax (Syntactic Sugar)**\n\nThe `class` syntax, introduced in ES6, provides a cleaner, more familiar syntax for setting up prototypal inheritance. Under the hood, it still uses the same prototypal model. The `extends` keyword automatically sets up the prototype chain.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  eat() {\n    console.log(`${this.name} is eating.`);\n  }\n}\n\nclass Dog extends Animal {\n  bark() {\n    console.log("Woof! Woof!");\n  }\n}\n\nconst myDog = new Dog(\'Rex\');\nmyDog.eat();  // "Rex is eating." -> Inherited from Animal\nmyDog.bark(); // "Woof! Woof!" -> Own method\n```'
      },
      'constructors': {
        title: 'Constructors and the new keyword',
        content: '### Constructors and the `new` keyword\n\nIn JavaScript, a **constructor function** is a regular function used to create and initialize multiple objects of the same type. The `new` keyword is the operator used to invoke a function as a constructor.\n\nThis pattern was the standard way to create "classes" of objects before the `class` syntax was introduced in ES6.\n\n---\n\n#### What is a Constructor Function?\n\nBy convention, constructor functions start with a capital letter (e.g., `Person`, `Car`). They are designed to be called with the `new` keyword. Inside the function, the `this` keyword refers to the new object being created.\n\n```javascript\n// This is a constructor function\nfunction Person(firstName, lastName) {\n  // `this` refers to the new empty object being created\n\n  // 1. Add properties to the new object\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n```\n\n---\n\n#### What Does the `new` Keyword Do?\n\nWhen you call a function using the `new` keyword (e.g., `new Person(...)`), it triggers a special four-step process:\n\n1.  **Creates a New Empty Object:** A new, plain JavaScript object is created in memory (e.g., `{}`).\n2.  **Sets the Prototype:** The new object\'s internal `[[Prototype]]` property is linked to the constructor function\'s `prototype` property. This is how the new object inherits methods (e.g., `newObject.[[Prototype]] = Person.prototype`).\n3.  **Binds `this`:** The `this` keyword inside the constructor function is set to point to the newly created object. This allows the function to add properties and methods to the new object.\n4.  **Returns the Object:** The new object is returned automatically from the function. (The only exception is if the function explicitly returns a different object).\n\n---\n\n#### Putting It All Together: An Example\n\nLet\'s add a shared method to our `Person` constructor\'s prototype. Methods should be placed on the `.prototype` property so that all instances share the same function in memory, which is more efficient.\n\n```javascript\nfunction Person(firstName, lastName) {\n  // `this` is bound to the new object\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\n// Add a method to the prototype.\n// All instances created by `new Person` will share this method.\nPerson.prototype.getFullName = function() {\n  return `${this.firstName} ${this.lastName}`;\n};\n\n// Use the `new` keyword to create instances (objects)\nconst person1 = new Person(\'Ibrahem\', \'Bastawi\');\nconst person2 = new Person(\'John\', \'Doe\');\n\n// Call the methods\nconsole.log(person1.getFullName()); // "Ibrahem Bastawi"\nconsole.log(person2.getFullName()); // "John Doe"\n\n// Checking the prototype chain\nconsole.log(person1 instanceof Person); // true\nconsole.log(Object.getPrototypeOf(person1) === Person.prototype); // true\n```\n\nIn this example:\n*   `person1` and `person2` are two distinct objects.\n*   Each has its own `firstName` and `lastName` properties.\n*   However, they both share the *exact same* `getFullName` function through their link to `Person.prototype`.\n\nThis pattern provides a blueprint for creating objects, which is the foundation of object-oriented programming in classic JavaScript. The ES6 `class` syntax is largely "syntactic sugar" that simplifies this exact process.'
      },
      'es6-classes': {
        title: 'ES6 Classes',
        content: '### ES6 Classes\n\nThe `class` syntax was introduced in ES6 to provide a cleaner, more modern, and more familiar way to create objects and handle inheritance in JavaScript. It is important to know that ES6 classes are primarily **syntactic sugar** over JavaScript\'s existing prototypal inheritance model. They do not introduce a new object-oriented inheritance model.\n\n---\n\n#### Basic Class Syntax\n\nA class is a blueprint for creating objects. It encapsulates data (properties) and behavior (methods).\n\n*   **`class` keyword:** Used to declare a class.\n*   **`constructor()` method:** A special method for creating and initializing an object created with a class. It is called automatically when an instance of the class is created with `new`. There can only be one `constructor` per class.\n*   **Methods:** Declared directly inside the class body. These methods are automatically added to the class\'s prototype.\n\n```javascript\nclass Person {\n  // The constructor is called when we do `new Person(...)`\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  // This is a method. It will be added to Person.prototype\n  greet() {\n    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);\n  }\n}\n\n// Create an instance (an object) of the Person class\nconst ibrahem = new Person(\'Ibrahem\', 30);\nibrahem.greet(); // "Hello, my name is Ibrahem and I am 30 years old."\n```\n\nThis syntax is equivalent to the constructor function pattern but is much more organized and readable.\n\n---\n\n#### Inheritance with `extends` and `super`\n\nES6 classes make inheritance straightforward using the `extends` and `super` keywords.\n\n*   **`extends`:** Used to create a child class that inherits from a parent class. The child class gets access to all the properties and methods of the parent.\n*   **`super`:** A special keyword with two main uses:\n    1.  **`super()` in a constructor:** Used to call the parent class\'s constructor. You **must** call `super()` in a child class constructor *before* using the `this` keyword.\n    2.  **`super.methodName()`:** Used to call a method from the parent class.\n\n**Example:**\n\n```javascript\n// Parent Class\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\n// Child Class inheriting from Animal\nclass Dog extends Animal {\n  constructor(name, breed) {\n    // 1. Call the parent constructor with super()\n    super(name);\n    this.breed = breed;\n  }\n\n  // 2. Override the parent\'s speak method\n  speak() {\n    // 3. Optionally, call the parent method with super.speak()\n    super.speak();\n    console.log(`${this.name} barks.`);\n  }\n}\n\nconst myDog = new Dog(\'Rex\', \'German Shepherd\');\nmyDog.speak();\n// Output:\n// "Rex makes a noise."\n// "Rex barks."\n```\n\n---\n\n#### Key Takeaways\n\n*   **Syntactic Sugar:** Classes are a cleaner syntax for the same prototypal inheritance that has always existed in JavaScript.\n*   **Clarity:** They provide a more structured and less error-prone way to create blueprints for objects.\n*   **`constructor`:** The special initialization method.\n*   **`extends`:** The keyword for inheritance.\n*   **`super`:** The keyword to access the parent class\'s constructor and methods.\n*   **Hoisting:** Unlike function declarations, class declarations are **not** hoisted. You must declare a class before you can use it.'
      }
    }
  },
  {
    title: 'Modern JavaScript (ES6+)',
    topics: {
      'destructuring': {
        title: 'Destructuring',
        content: '### Destructuring\n\nDestructuring is an ES6 feature that provides a convenient way to extract data from arrays or objects and assign them to distinct variables. It makes your code cleaner and more readable by reducing the need for repetitive dot notation or bracket notation.\n\n---\n\n#### 1. Object Destructuring\n\nObject destructuring allows you to unpack properties from an object into variables with the same name.\n\n**Basic Usage:**\n```javascript\nconst person = {\n  firstName: \'Ibrahem\',\n  lastName: \'Bastawi\',\n  age: 30\n};\n\n// Instead of:\n// const firstName = person.firstName;\n// const age = person.age;\n\n// You can do this:\nconst { firstName, age } = person;\n\nconsole.log(firstName); // "Ibrahem"\nconsole.log(age);       // 30\n```\n\n**Renaming Variables:**\nYou can assign the property to a variable with a different name using a colon (`:`).\n```javascript\nconst { firstName: fName, lastName: lName } = person;\n\nconsole.log(fName); // "Ibrahem"\n// console.log(firstName); // Throws ReferenceError```\n\n**Default Values:**\nYou can provide a default value for a property that may not exist on the object.```javascript\nconst { city = \'Cairo\' } = person;\n\nconsole.log(city); // "Cairo"```\n\n**Nested Destructuring:**\nYou can also destructure nested objects.\n```javascript\nconst user = {\n  id: 1,\n  details: {\n    name: \'John\',\n    location: \'US\'\n  }\n};\n\nconst { details: { name, location } } = user;\nconsole.log(name);     // "John"\nconsole.log(location); // "US"\n```\n\n---\n\n#### 2. Array Destructuring\n\nArray destructuring allows you to unpack values from an array into variables based on their **position**.\n\n**Basic Usage:**\n```javascript\nconst colors = [\'Red\', \'Green\', \'Blue\'];\n\n// Instead of:\n// const firstColor = colors[0];\n// const secondColor = colors[1];\n\n// You can do this:\nconst [firstColor, secondColor] = colors;\n\nconsole.log(firstColor);  // "Red"\nconsole.log(secondColor); // "Green"\n```\n\n**Skipping Elements:**\nYou can use a comma to skip an element you don\'t need.\n```javascript\nconst [ , , thirdColor] = colors;\nconsole.log(thirdColor); // "Blue"\n```\n\n**Rest Pattern:**\nYou can use the rest operator (`...`) to collect the remaining elements of an array into a new array. The rest operator must be the last element in the destructuring assignment.\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconst [first, second, ...restOfTheNumbers] = numbers;\n\nconsole.log(first);             // 1\nconsole.log(second);            // 2\nconsole.log(restOfTheNumbers);  // [3, 4, 5]\n```\n\n**Default Values:**\nSimilar to object destructuring, you can provide default values for array elements.\n```javascript\nconst settings = [\'Dark\'];\nconst [theme = \'Light\', fontSize = 16] = settings;\n\nconsole.log(theme);    // "Dark" (from the array)\nconsole.log(fontSize); // 16 (default value is used)\n```\n\n---\n\n#### Practical Use Cases\n\n**Function Parameters:**\nDestructuring is extremely useful for handling function parameters, especially when dealing with an options object.\n```javascript\n// Instead of: function drawChart(options) { const color = options.color; ... }\n\nfunction drawChart({ color = \'blue\', width = 600, height = 400 }) {\n  console.log(`Drawing a chart with color ${color} and size ${width}x${height}`);\n}\n\ndrawChart({ color: \'red\', height: 300 }); // "Drawing a chart with color red and size 600x300"\n```\n\n**Swapping Variables:**\nDestructuring provides a clean, one-line way to swap the values of two variables.\n```javascript\nlet a = 1;\nlet b = 2;\n\n[a, b] = [b, a]; // The magic happens here\n\nconsole.log(a); // 2\nconsole.log(b); // 1\n```'
      },
      'spread-and-rest-operators': {
        title: 'Spread and Rest Operators',
        content: '### Spread (`...`) and Rest (`...`) Operators\n\nThe `...` syntax in JavaScript is used for two distinct but related concepts: the **Spread Operator** and the **Rest Parameter**. The meaning of `...` changes depending on where it is used.\n\n*   **Spread (`...`)**: *Expands* an iterable (like an array or string) or an object\'s properties. It\'s used where multiple elements or properties are expected.\n*   **Rest (`...`)**: *Collects* multiple elements or properties into a single array or object. It\'s used in function parameters and destructuring assignments.\n\n---\n\n#### 1. The Spread Operator\n\nThe spread operator unpacks elements. Think of it as taking a container and spreading its contents out.\n\n**Use with Arrays:**\n```javascript\n// 1. Combining Arrays\nconst fruits = [\'apple\', \'banana\'];\nconst vegetables = [\'carrot\', \'potato\'];\nconst food = [...fruits, ...vegetables];\nconsole.log(food); // [\'apple\', \'banana\', \'carrot\', \'potato\']\n\n// 2. Copying an Array (shallow copy)\nconst original = [1, 2, 3];\nconst copy = [...original];\ncopy.push(4);\nconsole.log(original); // [1, 2, 3] (original is not affected)\nconsole.log(copy);     // [1, 2, 3, 4]\n\n// 3. Passing Array Elements as Function Arguments\nconst numbers = [10, 5, 25];\nconst maxNumber = Math.max(...numbers); // Equivalent to Math.max(10, 5, 25)\nconsole.log(maxNumber); // 25\n```\n\n**Use with Objects:**\n```javascript\n// 1. Combining Objects\nconst user = { name: \'Ibrahem\', age: 30 };\nconst job = { title: \'Engineer\', company: \'Google\' };\nconst employee = { ...user, ...job, location: \'Cairo\' };\nconsole.log(employee); // { name: \'Ibrahem\', age: 30, title: \'Engineer\', company: \'Google\', location: \'Cairo\' }\n// Note: If properties overlap, the last object\'s property wins.\n\n// 2. Copying an Object (shallow copy)\nconst originalObj = { a: 1, b: 2 };\nconst copyObj = { ...originalObj };\nconsole.log(copyObj); // { a: 1, b: 2 }\n```\n\n---\n\n#### 2. The Rest Parameter / Rest Property\n\nThe rest syntax collects elements into a single container. Think of it as gathering up a list of items into an array. **It must always be the last element** in a function parameter list or a destructuring assignment.\n\n**Use in Function Parameters:**\nIt allows a function to accept an indefinite number of arguments as an array.\n```javascript\nfunction sum(...numbers) {\n  // `numbers` is a true array containing all arguments passed to the function\n  return numbers.reduce((total, num) => total + num, 0);\n}\n\nconsole.log(sum(1, 2));             // 3\nconsole.log(sum(1, 2, 3, 4, 5));    // 15\nconsole.log(sum());                 // 0\n```\n\n**Use in Destructuring:**\nIt gathers the remaining elements into a new array or object.\n```javascript\n// 1. Array Destructuring\nconst scores = [95, 88, 76, 65, 50];\nconst [winner, runnerUp, ...others] = scores;\n\nconsole.log(winner);   // 95\nconsole.log(runnerUp); // 88\nconsole.log(others);   // [76, 65, 50]\n\n// 2. Object Destructuring\nconst person = {\n  name: \'John\',\n  age: 40,\n  city: \'New York\',\n  country: \'USA\'\n};\n\nconst { name, age, ...address } = person;\n\nconsole.log(name);    // \'John\'\nconsole.log(age);     // 40\nconsole.log(address); // { city: \'New York\', country: \'USA\' }\n```\n\n---\n\n### Summary\n\n| Operator | Action | Used In | Example |\n| :--- | :--- | :--- | :--- |\n| **Spread** | **Expands** | Function calls, array literals, object literals | `const arr = [1, ...otherArr];` |\n| **Rest** | **Collects** | Function parameters, destructuring assignments| `function sum(...args) {}` |'
      },
      'modules': {
        title: 'Modules: import and export',
        content: '### Modules: `import` and `export`\n\nJavaScript Modules (ES Modules or ESM) are the standard, built-in way to organize and share code across multiple files. A module is simply a file. By using modules, you can keep your code structured, prevent global scope pollution, and reuse code efficiently.\n\nThe two core keywords for modules are `export` and `import`.\n\n*   **`export`**: Makes variables, functions, or classes from one module available to other modules.\n*   **`import`**: Pulls in exported code from another module to be used in the current module.\n\n---\n\n#### `export`: Making Code Available\n\nThere are two main types of exports: **Named Exports** and **Default Exports**.\n\n**1. Named Exports**\n\nYou can have **multiple** named exports per module. This is useful for exporting a collection of utility functions or values. The name of the imported variable must be the same as the name of the exported variable.\n\n```javascript\n//  utils.js\n\nexport const PI = 3.14159;\n\nexport function add(a, b) {\n  return a + b;\n}\n\nexport class Calculator {\n  // ... class implementation\n}\n```\n\n**2. Default Export**\n\nYou can only have **one** default export per module. This is typically used for the "main" thing the module provides, like a primary class or function (e.g., a React component).\n\n```javascript\n//  Greeter.js\n\nexport default function greet(name) {\n  return `Hello, ${name}!`;\n}\n\n// Or for a class:\n// export default class Greeter { ... }\n```\n\n---\n\n#### `import`: Using Exported Code\n\n**1. Importing Named Exports**\n\nYou must use curly braces `{ }` to import named exports, and the names inside the braces must match the exported names.\n\n```javascript\n//  main.js\nimport { PI, add } from \'./utils.js\';\n\nconsole.log(PI); // 3.14159\nconsole.log(add(5, 10)); // 15\n```\n\n*   **Renaming with `as`**: If there\'s a naming conflict, you can rename an import.\n    ```javascript\n    import { add as sum } from \'./utils.js\';\n    console.log(sum(2, 3)); // 5\n    ```\n\n*   **Importing Everything**: You can import all named exports into a single object.\n    ```javascript\n    import * as utils from \'./utils.js\';\n    console.log(utils.PI);\n    console.log(utils.add(2, 3));\n    ```\n\n**2. Importing a Default Export**\n\nYou import a default export without curly braces, and you can give it any name you want.\n\n```javascript\n//  main.js\nimport myGreetingFunction from \'./Greeter.js\'; // You can name it anything\n\nconsole.log(myGreetingFunction(\'Ibrahem\')); // "Hello, Ibrahem!"\n```\n\n**3. Importing Both Default and Named Exports**\n\nYou can combine both types of imports in a single statement. The default import must come first.\n\n```javascript\n//  module.js\nexport default function mainFunc() { /* ... */ }\nexport const helper = () => { /* ... */ };\n\n//  app.js\nimport mainFunc, { helper } from \'./module.js\';\n```\n\n---\n\n#### How to Use Modules in the Browser\n\nTo use ES Modules in a browser, you must add `type="module"` to your `<script>` tag in your HTML file. This tells the browser to treat the file as a module, allowing it to use `import` and `export`.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>My App</title>\n  </head>\n  <body>\n    <!-- This script is a module -->\n    <script type="module" src="main.js"></script>\n  </body>\n</html>\n```'
      },
      'array-methods': {
        title: 'Array Methods: map, filter, reduce, find, forEach',
        content: '### Array Methods: `map`, `filter`, `reduce`, `find`, `forEach`\n\nThese are essential higher-order functions in JavaScript for working with arrays. They allow you to write more declarative and readable code by abstracting away the manual looping process.\n\n---\n\n#### `forEach(callback)`\n\n*   **What it does:** Executes a provided function once for each array element. It\'s a modern replacement for a `for` loop.\n*   **Return value:** `undefined`.\n*   **Use case:** When you need to iterate over an array to perform an action (a "side effect") for each element, like logging to the console or updating a DOM element. **It does not create a new array.**\n\n```javascript\nconst fruits = [\'apple\', \'banana\', \'cherry\'];\n\nfruits.forEach((fruit, index) => {\n  console.log(`Fruit at index ${index} is ${fruit}`);\n});\n// Logs:\n// "Fruit at index 0 is apple"\n// "Fruit at index 1 is banana"\n// "Fruit at index 2 is cherry"\n```\n\n---\n\n#### `map(callback)`\n\n*   **What it does:** Creates a **new array** by calling a provided function on every element in the original array and storing the results.\n*   **Return value:** A **new array** of the same length as the original.\n*   **Use case:** When you want to **transform** each element of an array into something new.\n\n```javascript\nconst numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n\nconst users = [{ name: \'Ibrahem\' }, { name: \'John\' }];\nconst names = users.map(user => user.name);\nconsole.log(names); // [\'Ibrahem\', \'John\']```\n\n---\n\n#### `filter(callback)`\n\n*   **What it does:** Creates a **new array** containing all elements from the original array that pass a test (i.e., the callback function returns `true`).\n*   **Return value:** A **new array** that is a subset of the original array. Its length can be less than or equal to the original.\n*   **Use case:** When you want to **select** a subset of elements from an array based on a condition.\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5, 6];\nconst evenNumbers = numbers.filter(num => num % 2 === 0);\nconsole.log(evenNumbers); // [2, 4, 6]\n\nconst products = [\n  { name: \'Laptop\', price: 1200 },\n  { name: \'Mouse\', price: 25 },\n  { name: \'Keyboard\', price: 75 }\n];\nconst affordableProducts = products.filter(product => product.price < 100);\nconsole.log(affordableProducts); // [{ name: \'Mouse\', price: 25 }, { name: \'Keyboard\', price: 75 }]```\n\n---\n\n#### `reduce(callback, initialValue)`\n\n*   **What it does:** Executes a "reducer" function on each element of the array, resulting in a single accumulated output value. It is the most versatile of these methods.\n*   **Return value:** The single, accumulated value.\n*   **Callback arguments:** The callback function takes two main arguments: `(accumulator, currentValue)`. The `accumulator` is the value returned from the previous iteration, and `currentValue` is the current element being processed.\n*   **Use case:** Summing an array, counting occurrences, flattening an array of arrays, grouping objects by a property.\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\n// The `0` is the initialValue for the accumulator (total)\nconst sum = numbers.reduce((total, currentNumber) => total + currentNumber, 0);\nconsole.log(sum); // 15\n```\n\n---\n\n#### `find(callback)`\n\n*   **What it does:** Returns the **first element** in the array that satisfies the provided testing function. It stops searching as soon as it finds a match.\n*   **Return value:** The first matching **element**, or `undefined` if no element is found.\n*   **Use case:** When you need to find a single, specific item in an array.\n\n```javascript\nconst users = [\n  { id: 1, name: \'John\' },\n  { id: 2, name: \'Ibrahem\' },\n  { id: 3, name: \'Jane\' }\n];\n\nconst userIbrahem = users.find(user => user.name === \'Ibrahem\');\nconsole.log(userIbrahem); // { id: 2, name: \'Ibrahem\' }\n\nconst userNotFound = users.find(user => user.id === 4);\nconsole.log(userNotFound); // undefined\n```'
      }
    }
  }
];