import type { TopicCategory } from './types';

export const typescriptTopics: TopicCategory[] = [
  {
    title: "TypeScript Fundamentals",
    topics: {
      "what-is-typescript": {
        title: "What is TypeScript?",
        content: "### What is TypeScript?\n\nTypeScript is a programming language developed by Microsoft that builds on top of JavaScript. It is a \"syntactic superset\" of JavaScript, which means all valid JavaScript code is also valid TypeScript code. TypeScript's primary addition to JavaScript is static typing.\n\n---\n\n#### Relationship to JavaScript\n\n*   **Superset, Not a Replacement:** TypeScript doesn't replace JavaScript. Instead, you write TypeScript code, which is then \"transpiled\" (compiled) into plain JavaScript that can run in any browser or Node.js environment.\n*   **Compatibility:** You can gradually introduce TypeScript into an existing JavaScript project. It seamlessly works with all existing JavaScript libraries and code.\n\n---\n\n#### Benefits of Static Typing\n\nIn JavaScript, a variable's type can change unexpectedly (dynamic typing). TypeScript allows you to declare a variable's type upfront (static typing), which prevents many common bugs.\n\nThe main benefits are:\n\n*   **Early Error Detection:** TypeScript's compiler catches type-related errors during development, before the code is ever run. This prevents bugs that might otherwise only appear for users in production.\n*   **Improved Readability and Documentation:** Explicitly stating types makes your code clearer and easier for other developers (or your future self) to understand. The types serve as a form of documentation.\n*   **Better Tooling and Autocomplete:** IDEs and code editors can use type information to provide smarter autocompletion, error checking, and safer code refactoring.\n\n---\n\n#### Example: The Core Difference\n\nHere is a simple function in both JavaScript and TypeScript that shows the benefit.\n\n**JavaScript (Dynamic Typing)**\n```javascript\nfunction greet(person, date) {\n  console.log(\\`Hello \\${person}, today is \\${date}!\\`);\n}\n\ngreet(\"Brendan\", new Date()); // Works as expected\n\n// BUG: This will run without error, but produce a weird result.\n// The .toDateString() method doesn't exist on a string.\ngreet(\"Brendan\", \"01/01/2023\"); // \"Hello Brendan, today is 01/01/2023!\"\n```\nThe bug in the second function call might go unnoticed and cause problems later.\n\n**TypeScript (Static Typing)**\n\nIn TypeScript, we add \"type annotations\" to the function parameters.\n\n```typescript\nfunction greet(person: string, date: Date) {\n  console.log(\\`Hello \\${person}, today is \\${date.toDateString()}!\\`);\n}\n\ngreet(\"Brendan\", new Date()); // Works as expected\n\n// ERROR: This line will show an error *before you run the code*.\n// Argument of type 'string' is not assignable to parameter of type 'Date'.\ngreet(\"Brendan\", \"01/01/2023\");\n```\n\nTypeScript identifies the error immediately, preventing the bug from ever making it into the application."
      },
      "core-types": {
        title: "Core Types",
        content: "### Core Types\n\nTypeScript provides several built-in types for basic values. These annotations are used after a variable or function parameter, preceded by a colon (:).\n\n| Type | Description | Example |\n| :--- | :--- | :--- |\n| `string` | Represents text values. | `let name: string = \"Alice\";` |\n| `number` | Represents all numbers (integers and floats). | `let age: number = 30;` |\n| `boolean` | Represents `true` or `false` values. | `let isLoggedIn: boolean = true;` |\n| `Array` | Represents an array of values of a specific type. Written as `Type[]` or `Array<Type>`. | `let list: number[] = [1, 2, 3];` |\n| `any` | Opt-out of type checking. Allows any value. Use it sparingly as it defeats the purpose of TypeScript. | `let flexible: any = \"hello\";` |\n| `unknown` | A type-safe alternative to `any`. You must perform a type check before using the variable. | `let data: unknown = getFromAPI();` |\n| `void` | Represents the absence of a value, typically used for functions that don't return anything. | `function log(msg: string): void { ... }` |\n| `never` | Represents a value that will never occur. Used for functions that always throw an error or never end. | `function error(): never { throw new Error(); }` |\n\n---\n\n#### Key Concepts\n\n**Type Safety:** TypeScript helps you avoid mistakes by ensuring you don't assign a value of the wrong type to a variable.\n\n```typescript\nlet name: string = \"Alice\";\n// ERROR: Type 'number' is not assignable to type 'string'.\nname = 123;\n```\n\n**`any` vs. `unknown`:**\n\n*   With `any`, you can perform any operation without checks, which is risky.\n*   With `unknown`, TypeScript forces you to narrow the type before you can use it, which is much safer.\n\n```typescript\nlet value: unknown = \"hello world\";\n\n// ERROR: 'value' is of type 'unknown'.\n// value.toUpperCase();\n\nif (typeof value === \"string\") {\n  // OK: TypeScript now knows 'value' is a string in this block.\n  console.log(value.toUpperCase());\n}\n```"
      },
      "type-annotations-inference": {
        title: "Type Annotations & Inference",
        content: "### Type Annotations & Inference\n\nTypeScript has two ways of knowing a variable's type: explicitly telling it (annotation) or letting it figure it out on its own (inference).\n\n---\n\n#### 1. Type Annotation (Explicit)\n\nThis is when you explicitly tell TypeScript the type of a variable using the colon (:) syntax.\n\n**When to use it:**\n\n*   When you declare a variable but don't initialize it immediately.\n*   For function parameters and return values to define a clear contract.\n*   When you want to override a type that TypeScript might infer incorrectly.\n\n```typescript\n// Annotation for a variable\nlet name: string;\nname = \"Alice\";\n\n// Annotation for function parameters and return value\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n```\n\n---\n\n#### 2. Type Inference (Implicit)\n\nThis is when TypeScript automatically deduces the type of a variable based on the value you assign to it at declaration. This keeps your code cleaner.\n\n```typescript\n// Inferred as \\`string\\` because it's initialized with a string\nlet greeting = \"hello\";\n\n// Inferred as \\`number\\`\nlet age = 30;\n```\n\nIf you try to assign a different type later, TypeScript will still throw an error because the type was \"locked in\" at initialization.\n\n```typescript\nlet age = 30; // TypeScript infers 'age' is of type 'number'\n\n// ERROR: Type 'string' is not assignable to type 'number'.\nage = \"thirty\";\n```\n\n---\n\n#### Best Practice\n\n*   Rely on inference whenever possible for cleaner code (e.g., `let name = \"Bob\"` is better than `let name: string = \"Bob\"`).  \n*   Use annotations for function signatures and when you are not initializing a variable right away. This makes your code's intentions clear."
      },
      "interfaces-vs-type-aliases": {
        title: "Interfaces vs. Type Aliases",
        content: "### Interfaces vs. Type Aliases\n\nBoth `interface` and `type` aliases are used to define the \"shape\" of an object or a reusable type. For simple object shapes, they are very similar, but they have key differences.\n\n---\n\n#### 1. Type Alias\n\nA type alias gives a new name to any type, including primitives, unions, or objects. It is defined with the `type` keyword.\n\n```typescript\n// For a complex object\ntype Person = {\n  name: string;\n  age: number;\n  isStudent?: boolean; // Optional property\n};\n\n// For a union of types\ntype StringOrNumber = string | number;\n\n// For a primitive\ntype UserID = string;\n```\n\n---\n\n#### 2. Interface\n\nAn interface is a way to define a contract for an object's shape. It can only be used for objects, not primitives. It is defined with the `interface` keyword.\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n  isStudent?: boolean; // Optional property\n}\n\n// You can extend an interface\ninterface Employee extends Person {\n  employeeId: number;\n}\n```\n\n---\n\n#### Key Differences\n\n| Feature | `interface` | `type` Alias |\n| :--- | :--- | :--- |\n| **Can Define** | Only object shapes. | Any type (objects, primitives, unions, etc.). |\n| **Extending** | Uses the `extends` keyword. | Uses intersection types (`&`). `type Employee = Person & { employeeId: number };` |\n| **Declaration Merging** | Yes. An interface can be defined multiple times and will be merged. | No. You cannot declare the same type alias more than once. |\n\n---\n\n#### Declaration Merging Example (Interface Only)\n\nYou can add new properties to an existing interface, which is useful when working with third-party libraries.\n\n```typescript\ninterface User {\n  name: string;\n}\n\n// Later in the code...\ninterface User {\n  age: number;\n}\n\nconst myUser: User = { name: \"Alice\", age: 30 }; // This is valid\n```\n\n---\n\n#### When to Use Which? (Best Practice)\n\n*   Use **`interface`** when defining the shape of objects or when you might need its extensibility features (like declaration merging). It's the common choice for object-oriented programming with classes.\n*   Use **`type`** when you need to define a union, intersection, tuple, or a named primitive. It is more versatile for non-object types."
      }
    }
  },
  {
    title: "Advanced Types & Features",
    topics: {
      "union-intersection-types": {
        title: "Union & Intersection Types",
        content: "### Union & Intersection Types\n\nThese are powerful features for combining existing types to create new, more flexible ones.\n\n---\n\n#### 1. Union Types (`|`)\n\nA union type allows a variable to be one of several possible types. It's like an \"OR\" condition.\n\n**Use Case:** When a value can be one of a few different, known types. For example, a function that accepts either a string or a number.\n\n```typescript\nfunction printId(id: string | number) {\n  // TypeScript will show an error if you try to use a method\n  // that doesn't exist on BOTH types.\n  // console.log(id.toUpperCase()); // Error: Property 'toUpperCase' does not exist on type 'number'.\n\n  // You must use a type guard to narrow the type first.\n  if (typeof id === \"string\") {\n    // Inside this block, TypeScript knows 'id' is a string.\n    console.log(id.toUpperCase());\n  } else {\n    // Here, it knows 'id' is a number.\n    console.log(id);\n  }\n}\n\nprintId(101);       // Prints \"101\"\nprintId(\"202-A\");   // Prints \"202-A\"\n```\n\n---\n\n#### 2. Intersection Types (`&`)\n\nAn intersection type combines multiple types into a single one that has all the properties of the combined types. It's like an \"AND\" condition.\n\n**Use Case:** To merge different object shapes into a new, combined shape.\n\n```typescript\ntype Draggable = {\n  drag: () => void;\n};\n\ntype Resizable = {\n  resize: () => void;\n};\n\n// This new type has ALL properties of Draggable AND Resizable.\ntype UIWidget = Draggable & Resizable;\n\nlet textBox: UIWidget = {\n  drag: () => console.log(\"Dragging...\"),\n  resize: () => console.log(\"Resizing...\"),\n};\n\ntextBox.drag();\ntextBox.resize();\n```\n\n---\n\n#### Summary\n\n| Type | Symbol | Analogy | Meaning |\n| :--- | :---: | :--- | :--- |\n| **Union** | `|` | OR | The value can be **one of** the types. |\n| **Intersection** | `&` | AND | The object must have **all of** the properties. |"
      },
      "generics": {
        title: "Generics",
        content: "### Generics\n\nGenerics are a powerful feature that allows you to create reusable components, functions, and data structures that can work with a variety of types instead of being limited to a single one. You can think of them as **variables for types**.\n\nThe syntax uses angle brackets with a type variable, commonly `<T>` (for Type).\n\n---\n\n#### The Problem Generics Solve\n\nWithout generics, you have two bad options for creating a flexible function:\n\n1.  **Use `any`:** This is not type-safe and defeats the purpose of TypeScript.\n2.  **Write a separate function for each type:** This leads to a lot of duplicate code.\n\n---\n\n#### Example: A Simple Generic Function\n\nLet's create a function that takes an argument and returns it wrapped in an array.\n\n**Without Generics (using `any`) - Bad**\n\n```typescript\nfunction wrapInArray(input: any): any[] {\n  return [input];\n}\n\nconst numbers = wrapInArray(10); // Type is any[]. We lose the type info.\nconst strings = wrapInArray(\"hello\"); // Type is any[].\n```\n\nWe don't know what's in the array afterwards. `numbers[0].toFixed(2)` would not be suggested by autocomplete.\n\n**With Generics - Good**\n\n```typescript\nfunction wrapInArray<T>(input: T): T[] {\n  return [input];\n}\n\n// TypeScript infers the type of T based on the input\nconst numbers = wrapInArray(10); // Type is number[]. Type info is kept!\nconst strings = wrapInArray(\"hello\"); // Type is string[].\n\n// You can also explicitly set the type\nconst booleans = wrapInArray<boolean>(true); // Type is boolean[].\n```\n\nWith generics, TypeScript knows the exact type of the returned array, preserving type safety and enabling better tooling.\n\n---\n\n#### Generics with Interfaces and Types\n\nGenerics are also commonly used with interfaces and type aliases to create flexible data structures.\n\n```typescript\n// A generic interface for a standard API response\ninterface ApiResponse<T> {\n  data: T;\n  isError: boolean;\n}\n\n// We can reuse this interface for different data payloads\ntype UserResponse = ApiResponse<{ name: string; id: number }>;\ntype ProductResponse = ApiResponse<{ title: string; price: number }>;\n\nconst user: UserResponse = {\n  data: { name: \"Alice\", id: 1 },\n  isError: false,\n};\n\nconst product: ProductResponse = {\n  data: { title: \"Book\", price: 20 },\n  isError: false,\n};\n```"
      },
      "enums": {
        title: "Enums",
        content: "### Enums\n\nEnums (enumerations) allow you to define a set of named constants, making your code more readable and less prone to errors from using raw numbers or strings.\n\n---\n\n#### Why Use Enums?\n\n*   **Readability:** Replaces \"magic numbers\" or strings with meaningful names. `if (status === 0)` becomes `if (status === OrderStatus.Pending)`.\n*   **Type Safety:** Restricts a variable to a specific set of allowed values, preventing typos and invalid inputs.\n*   **Maintainability:** If a value needs to change, you only have to update it in one place (the enum definition).\n\nTypeScript offers two main types of enums: numeric and string.\n\n---\n\n#### 1. Numeric Enums\n\nBy default, enums assign incrementing numbers starting from 0.\n\n```typescript\nenum OrderStatus {\n  Pending,    // 0\n  Shipped,    // 1\n  Delivered,  // 2\n  Cancelled   // 3\n}\n\nlet myOrder = OrderStatus.Delivered;\nconsole.log(myOrder); // Output: 2\n```\n\nYou can also manually set the starting number.\n\n```typescript\nenum Direction {\n  Up = 1,\n  Down,     // 2\n  Left,     // 3\n  Right     // 4\n}\n```\n\n---\n\n#### 2. String Enums\n\nIn a string enum, you explicitly assign string values to each member. This is often preferred because the values are readable and meaningful when debugging.\n\n```typescript\nenum UserRole {\n  Admin = \"ADMIN\",\n  Editor = \"EDITOR\",\n  Viewer = \"VIEWER\"\n}\n\nfunction checkPermissions(role: UserRole) {\n  if (role === UserRole.Admin) {\n    console.log(\"Full access granted.\");\n  }\n}\n\ncheckPermissions(UserRole.Admin); // \"Full access granted.\"\n```\n\n---\n\n#### Best Practice\n\n*   **Prefer String Enums**: They provide more meaningful, readable values at runtime, which simplifies debugging."
      },
      "type-guards-narrowing": {
        title: "Type Guards & Narrowing",
        content: "### Type Guards & Narrowing\n\nWhen working with union types (e.g., `string | number`), TypeScript needs a way to know which specific type a variable is within a certain block of code. **Narrowing** is the process of refining a broad type into a more specific one. **Type guards** are expressions that perform a runtime check to guarantee the type in a specific scope, allowing TypeScript to narrow it down.\n\nHere are the most common type guards:\n\n---\n\n#### 1. `typeof` Type Guard\n\nThis is the most common way to narrow primitive types like `string`, `number`, `boolean`, `object`, `function`, `symbol`, and `undefined`.\n\n```typescript\nfunction processInput(input: string | number) {\n  if (typeof input === \"string\") {\n    // TypeScript now knows 'input' is a string.\n    console.log(input.toUpperCase());\n  } else {\n    // TypeScript knows 'input' must be a number here.\n    console.log(input.toFixed(2));\n  }\n}\n```\n\n---\n\n#### 2. `instanceof` Type Guard\n\nThe `instanceof` operator checks if an object is an instance of a specific class or constructor function. This is useful for narrowing down object types.\n\n```typescript\nclass Dog {\n  bark() { console.log(\"Woof!\"); }\n}\nclass Cat {\n  meow() { console.log(\"Meow!\"); }\n}\n\nfunction makeSound(pet: Dog | Cat) {\n  if (pet instanceof Dog) {\n    // TypeScript knows 'pet' is a Dog.\n    pet.bark();\n  } else {\n    // TypeScript knows 'pet' is a Cat.\n    pet.meow();\n  }\n}\n```\n\n---\n\n#### 3. Truthiness Narrowing\n\nThis simple guard checks if a value is \"truthy\" (not `null`, `undefined`, `false`, `0`, `\"\"`, or `NaN`). It's a quick way to filter out `null` and `undefined`.\n\n```typescript\nfunction print(value?: string | null) {\n  if (value) {\n    // TypeScript knows 'value' is a string here,\n    // because it filtered out null and undefined.\n    console.log(value.length);\n  }\n}\n```\n\n---\n\n#### 4. User-Defined Type Guards\n\nFor complex checks, you can create a custom type guard function. This is a function that returns a special type predicate: `parameterName is Type`.\n\n```typescript\n// Define a custom type for a Car\ninterface Car {\n  drive: () => void;\n}\n\n// User-defined type guard function\nfunction isCar(vehicle: any): vehicle is Car {\n  return typeof (vehicle as Car).drive === 'function';\n}\n\nfunction operate(vehicle: any) {\n  if (isCar(vehicle)) {\n    // TypeScript now knows 'vehicle' is of type Car.\n    vehicle.drive();\n  }\n}\n```"
      },
      "utility-types": {
        title: "Utility Types",
        content: "### Utility Types\n\nUtility types are built-in helpers in TypeScript that let you transform one type into another. This is useful for creating variations of existing types without having to write them from scratch.\n\nHere are some of the most common and useful utility types:\n\n---\n\n#### 1. `Partial<T>`\n\nConstructs a type with all properties of `T` set to optional. This is great for functions that update an object, where you only need to provide the properties that are changing.\n\n```typescript\ninterface User {\n  name: string;\n  age: number;\n}\n\nfunction updateUser(update: Partial<User>) {\n  // ...logic to update user\n}\n\n// All of these are valid:\nupdateUser({ name: \"Alice\" });\nupdateUser({ age: 31 });\nupdateUser({ name: \"Bob\", age: 40 });\n```\n\n---\n\n#### 2. `Readonly<T>`\n\nConstructs a type where all properties of `T` are set to `readonly`. This prevents you from re-assigning the properties of an object, helping enforce immutability.\n\n```typescript\ninterface Config {\n  apiUrl: string;\n}\n\nconst config: Readonly<Config> = {\n  apiUrl: \"https://api.example.com\",\n};\n\n// ERROR: Cannot assign to 'apiUrl' because it is a read-only property.\n// config.apiUrl = \"new-url\";\n```\n\n---\n\n#### 3. `Pick<T, K>`\n\nConstructs a type by picking a set of properties `K` (a string literal or union of string literals) from `T`. This is useful for creating a smaller, more specific type from a larger one.\n\n```typescript\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n\n// Create a new type with only 'title' and 'completed'\ntype TodoPreview = Pick<Todo, \"title\" | \"completed\">;\n\nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n};\n```\n\n---\n\n#### 4. `Omit<T, K>`\n\nConstructs a type by picking all properties from `T` and then removing the keys `K`. It's the opposite of `Pick`.\n\n```typescript\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  passwordHash: string;\n}\n\n// Create a public user type without sensitive info\ntype PublicUser = Omit<User, \"passwordHash\">;\n\nconst user: PublicUser = {\n  id: \"123\",\n  name: \"Alice\",\n  email: \"alice@example.com\",\n};\n```"
      }
    }
  },
  {
    title: "Object-Oriented TypeScript",
    topics: {
      "classes": {
        title: "Classes: Enhancing JavaScript with Access Modifiers",
        content: "### Classes: Enhancing JavaScript with Access Modifiers\n\nTypeScript adopts standard JavaScript (ES6) classes but enhances them with powerful features from object-oriented programming, most notably **access modifiers**. These modifiers control the visibility and accessibility of class members (properties and methods), a concept that doesn't exist in standard JavaScript.\n\nThe primary purpose of access modifiers is to achieve **encapsulation**â€”bundling data and the methods that operate on that data together, while restricting direct access to some of the object's components.\n\nThere are three main access modifiers: `public`, `private`, and `protected`.\n\n---\n\n#### 1. `public`\n\n**Description:** Members are accessible from anywhere, both inside and outside the class.\n\n**Default Behavior:** If you don't specify any modifier, the member is `public` by default.\n\n```typescript\nclass Animal {\n  public name: string;\n\n  public constructor(theName: string) {\n    this.name = theName;\n  }\n\n  public move(distanceInMeters: number) {\n    console.log(\\`\\${this.name} moved \\${distanceInMeters}m.\\`);\n  }\n}\n\nlet cat = new Animal(\"Cat\");\ncat.move(10); // Accessible from outside the class\nconsole.log(cat.name); // Accessible from outside the class\n```\n\n---\n\n#### 2. `private`\n\n**Description:** Members are only accessible from within the class where they are defined. This is the strictest modifier.\n\n**Use Case:** Hiding internal state or helper methods that should not be manipulated from outside the class.\n\n```typescript\nclass Person {\n  private ssn: string;\n\n  constructor(ssn: string) {\n    this.ssn = ssn;\n  }\n\n  public getSSN(): string {\n    // We can access it from a public method inside the class.\n    return this.ssn;\n  }\n}\n\nlet person = new Person(\"123-45-678\");\n// ERROR: Property 'ssn' is private and only accessible within class 'Person'.\n// console.log(person.ssn); \n\nconsole.log(person.getSSN()); // OK\n```\n\n---\n\n#### 3. `protected`\n\n**Description:** Members are accessible within the class they are defined in and by any subclasses (child classes) that inherit from it. They cannot be accessed from outside instances.\n\n**Use Case:** Sharing properties or methods with child classes while still hiding them from the public interface.\n\n```typescript\nclass Vehicle {\n  protected speed: number;\n\n  constructor() {\n    this.speed = 0;\n  }\n}\n\nclass Car extends Vehicle {\n  public accelerate() {\n    // Child class 'Car' can access the protected member 'speed'.\n    this.speed += 10;\n    console.log(\\`Speed is now \\${this.speed} km/h\\`);\n  }\n}\n\nlet car = new Car();\ncar.accelerate(); // OK\n\n// ERROR: Property 'speed' is protected and only accessible within\n// class 'Vehicle' and its subclasses.\n// console.log(car.speed);\n```"
      },
      "interfaces-for-classes": {
        title: "Interfaces: Enforcing a Structure on a Class",
        content: "### Interfaces: Enforcing a Structure on a Class\n\nIn TypeScript, an interface can be used to define a \"contract\" or a specific structure that a class must follow. When a class **implements** an interface, it is required to provide a concrete implementation for all the properties and methods declared in that interface.\n\nThis is one of the most common uses of interfaces in object-oriented programming. It ensures that different classes can be used interchangeably if they all adhere to the same contract.\n\n---\n\n#### How it Works: The `implements` Keyword\n\nYou use the `implements` keyword to make a class adhere to an interface. If the class fails to correctly implement all the members of the interface, TypeScript will generate an error at compile time.\n\n---\n\n#### Example\n\nLet's define a contract for things that can be logged.\n\n```typescript\n// 1. Define the Interface (the contract)\ninterface ILoggable {\n  // Any class implementing this must have a 'log' method\n  // that takes a string and returns nothing (void).\n  log(message: string): void;\n}\n\n// 2. Implement the Interface in different classes\n\n// A class for logging to the console\nclass ConsoleLogger implements ILoggable {\n  log(message: string): void {\n    console.log(\\`CONSOLE: \\${message}\\`);\n  }\n}\n\n// A class for logging to a fake web service\nclass WebServiceLogger implements ILoggable {\n  log(message: string): void {\n    // In a real app, this would send a network request\n    console.log(\\`SENT TO SERVICE: \\${message}\\`);\n  }\n}\n\n// A class that *incorrectly* implements the interface\nclass BadLogger implements ILoggable {\n  // ERROR: Property 'log' is missing in type 'BadLogger'\n  // but required in type 'ILoggable'.\n  logMessage(message: string): void { // Method name is wrong\n    console.log(message);\n  }\n}\n\n// 3. Use the classes\n// Because both classes implement ILoggable, we can treat them interchangeably.\nconst loggers: ILoggable[] = [new ConsoleLogger(), new WebServiceLogger()];\n\nloggers.forEach(logger => {\n  logger.log(\"This is a test message.\");\n});\n```\n\n---\n\n#### Key Points\n\n*   **Enforces a Contract:** The `implements` keyword is a check that the class provides the required structure. It doesn't change the class's type or implement the methods for you.\n*   **Public Side Only:** Interfaces only describe and check the public members of a class, not its private or protected members.\n*   **Multiple Interfaces:** A class can implement multiple interfaces, allowing it to adhere to several different contracts at once.\n\n```typescript\nclass MyComponent implements IClickable, IDraggable {\n  // ... must implement methods from both interfaces\n}\n```"
      }
    }
  },
  {
    title: "Configuration & Practical Usage",
    topics: {
      "tsconfig-json": {
        title: "tsconfig.json",
        content: "### tsconfig.json\n\nThe `tsconfig.json` file is the control center for your TypeScript project. It specifies the root files and the compiler options required to compile the project. This file allows you to configure how the TypeScript compiler (`tsc`) behaves, ensuring consistency across your team and development environment.\n\nYou can generate a default `tsconfig.json` file by running `tsc --init` in your project's root directory.\n\n---\n\n#### Key Compiler Options\n\nInside the `compilerOptions` object, you define how your code should be checked and transpiled.\n\n| Option | Description | Example Value |\n| :--- | :--- | :--- |\n| `target` | Specifies the ECMAScript target version for the output JavaScript. | `\"ES2022\"` |\n| `module` | Specifies the module code generation standard (e.g., CommonJS for Node.js, ESNext for modern browsers). | `\"NodeNext\"` |\n| `strict` | Enables all strict type-checking options, which is highly recommended for catching errors early. | `true` |\n| `esModuleInterop` | Improves compatibility between CommonJS and ES modules. | `true` |\n| `outDir` | The output directory for compiled JavaScript files. | `\"./dist\"` |\n| `rootDir` | Specifies the root directory of your input TypeScript files. | `\"./src\"` |\n| `skipLibCheck` | Skips type checking of all declaration files (`.d.ts`), which can speed up compilation. | `true` |\n\n---\n\n#### Example tsconfig.json\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es2022\",\n    \"module\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"]\n}\n```\n\nThis configuration tells the compiler to:\n\n*   Compile all files in the `src` directory.\n*   Output modern ES2022 JavaScript using Node.js module resolution.\n*   Enforce strict type-checking.\n*   Place the compiled `.js` files in a `dist` folder."
      },
      "modules": {
        title: "Modules: import and export",
        content: "### Modules: import and export\n\nTypeScript, just like modern JavaScript, uses ES Modules (ESM) as its primary way to organize code. Any file containing a top-level `import` or `export` is considered a module. Variables, functions, and classes inside a module are private to that module unless you explicitly export them.\n\n---\n\n#### 1. Named Exports\n\nYou can export multiple items from a single file by adding the `export` keyword before their declaration.\n\n**`math.ts`**\n\n```typescript\nexport const PI = 3.14;\n\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```\n\nTo use these, you import them using their exact names inside curly braces `{}`.\n\n**`app.ts`**\n\n```typescript\nimport { add, PI } from \"./math\";\n\nconsole.log(add(2, 3)); // 5\nconsole.log(PI);       // 3.14\n```\n\nYou can also rename imports using the `as` keyword.\n\n```typescript\nimport { add as sum } from \"./math\";\nconsole.log(sum(5, 10)); // 15\n```\n\n---\n\n#### 2. Default Exports\n\nA file can have only one default export. This is useful for modules that export a single primary class or function.\n\n**`logger.ts`**\n\n```typescript\nexport default function log(message: string): void {\n  console.log(message);\n}\n```\n\nYou can import a default export with any name you choose, without needing curly braces.\n\n**`app.ts`**\n\n```typescript\nimport myCustomLogger from \"./logger\";\n\nmyCustomLogger(\"Hello, world!\");\n```\n\n---\n\n#### 3. Type-Only Imports and Exports\n\nIf you only need to import a type or interface, you can use the `type` keyword. This makes it clear that the import has no runtime cost and will be erased during compilation.\n\n**`types.ts`**\n\n```typescript\nexport type User = {\n  name: string;\n  id: number;\n};\n```\n\n**`app.ts`**\n\n```typescript\nimport type { User } from \"./types\";\n\nconst alice: User = { name: \"Alice\", id: 1 };\n```\n\n---\n\n#### How tsconfig.json Affects Modules\n\nThe `\"module\"` option in your `tsconfig.json` tells TypeScript what module system the final JavaScript code should use.\n\n*   **`\"ESNext\"`**: Outputs modern `import`/`export` syntax. Use this for browsers or modern Node.js.\n*   **`\"NodeNext\"` or `\"CommonJS\"`**: Transpiles to `require()` and `module.exports`, the module system traditionally used in Node.js."
      },
      "declaration-files": {
        title: "Declaration Files (.d.ts)",
        content: "### Declaration Files (.d.ts)\n\nMany popular JavaScript libraries were not written in TypeScript. By default, when you try to use them in a TypeScript project, the compiler doesn't know what types their functions and variables have, so it treats them as `any`.\n\nDeclaration files solve this problem. They are special files (ending in `.d.ts`) that contain only type information and no implementation (no code). Their sole purpose is to describe the \"shape\" of existing JavaScript code to the TypeScript compiler.\n\n---\n\n#### What They Do:\n\n*   Provide type definitions for JavaScript libraries.\n*   Enable autocompletion and type-checking for plain JavaScript code.\n*   Act as a bridge between the TypeScript and JavaScript worlds.\n\n---\n\n#### How to Get Declaration Files\n\nThere are two primary sources for declaration files:\n\n1.  **Bundled with the Library:** Many modern JavaScript libraries are either written in TypeScript or ship with their own hand-written `.d.ts` files. When you install such a package, you get the types automatically.\n\n2.  **DefinitelyTyped (`@types`):** This is a massive, community-driven repository of declaration files for thousands of JavaScript libraries. If a library doesn't include its own types, you can almost always find them here. You install them from npm under the `@types` scope.\n\n---\n\n#### Example: Using a JavaScript Library (Lodash)\n\nLet's say you want to use the popular JavaScript utility library `lodash`.\n\n**1. Install the library and its types:**\n\n```bash\nnpm install lodash\nnpm install @types/lodash --save-dev\n```\n\n**2. Use it in your TypeScript code:**\n\n```typescript\nimport _ from 'lodash';\n\nconst numbers = [1, 2, 3, 4];\n\n// TypeScript knows \\`_.shuffle\\` exists, takes an array,\n// and returns an array of the same type.\nconst shuffled = _.shuffle(numbers);\n\nconsole.log(shuffled); // e.g., [3, 1, 4, 2]\n\n// TypeScript will give you an error if you use it incorrectly,\n// thanks to the @types/lodash declaration file.\n// ERROR: Argument of type 'string' is not assignable to parameter of type 'any[]'.\n// _.shuffle(\"hello\");\n```\n\nWithout `@types/lodash`, TypeScript would complain that it can't find the module `lodash` or would treat `_` as type `any`, removing all safety and autocompletion."
      }
    }
  }
];