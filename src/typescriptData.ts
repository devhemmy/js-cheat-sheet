export const typescriptTopics = [
  {
    title: "TypeScript Fundamentals",
    topics: {
      "what-is-typescript": {
        title: "What is TypeScript?",
        content: "### What is TypeScript?\n\nTypeScript is a programming language developed by Microsoft that builds on top of JavaScript. It is a \"syntactic superset\" of JavaScript, which means all valid JavaScript code is also valid TypeScript code. TypeScript's primary addition to JavaScript is static typing.\n\n#### Relationship to JavaScript\n\n*   **Superset, Not a Replacement:** TypeScript doesn't replace JavaScript. Instead, you write TypeScript code, which is then \"transpiled\" (compiled) into plain JavaScript that can run in any browser or Node.js environment.\n*   **Compatibility:** You can gradually introduce TypeScript into an existing JavaScript project. It seamlessly works with all existing JavaScript libraries and code.\n\n#### Benefits of Static Typing\n\nIn JavaScript, a variable's type can change unexpectedly (dynamic typing). TypeScript allows you to declare a variable's type upfront (static typing), which prevents many common bugs.\n\nThe main benefits are:\n*   **Early Error Detection:** TypeScript's compiler catches type-related errors during development, before the code is ever run. This prevents bugs that might otherwise only appear for users in production.\n*   **Improved Readability and Documentation:** Explicitly stating types makes your code clearer and easier for other developers (or your future self) to understand. The types serve as a form of documentation.\n*   **Better Tooling and Autocomplete:** IDEs and code editors can use type information to provide smarter autocompletion, error checking, and safer code refactoring.\n\n#### Example: The Core Difference\n\nHere is a simple function in both JavaScript and TypeScript that shows the benefit.\n\n**JavaScript (Dynamic Typing)**\n```javascript\nfunction greet(person, date) {\n  console.log(`Hello ${person}, today is ${date}!`);\n}\n\ngreet(\"Brendan\", new Date()); // Works as expected\n\n// BUG: This will run without error, but produce a weird result.\n// The .toDateString() method doesn't exist on a string.\ngreet(\"Brendan\", \"01/01/2023\"); // \"Hello Brendan, today is 01/01/2023!\"\n```\nThe bug in the second function call might go unnoticed and cause problems later.\n\n**TypeScript (Static Typing)**\nIn TypeScript, we add \"type annotations\" to the function parameters.\n```typescript\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n\ngreet(\"Brendan\", new Date()); // Works as expected\n\n// ERROR: This line will show an error *before you run the code*.\n// Argument of type 'string' is not assignable to parameter of type 'Date'.\ngreet(\"Brendan\", \"01/01/2023\");\n```\nTypeScript identifies the error immediately, preventing the bug from ever making it into the application."
      },
      "core-types": {
        title: "Core Types",
        content: "### Core Types\n\nTypeScript provides several built-in types for basic values. These annotations are used after a variable or function parameter, preceded by a colon (:).\n\n| Type | Description | Example |\n| :--- | :--- | :--- |\n| `string` | Represents text values. | `let name: string = \"Alice\";` |\n| `number` | Represents all numbers (integers and floats). | `let age: number = 30;` |\n| `boolean` | Represents `true` or `false` values. | `let isLoggedIn: boolean = true;` |\n| `Array` | Represents an array of values of a specific type. Written as `Type[]` or `Array<Type>`. | `let list: number[] = [1, 2, 3];` |\n| `any` | Opt-out of type checking. Allows any value. Use it sparingly as it defeats the purpose of TypeScript. | `let flexible: any = \"hello\";` |\n| `unknown` | A type-safe alternative to `any`. You must perform a type check before using the variable. | `let data: unknown = getFromAPI();` |\n| `void` | Represents the absence of a value, typically used for functions that don't return anything. | `function log(msg: string): void { ... }` |\n| `never` | Represents a value that will never occur. Used for functions that always throw an error or never end. | `function error(): never { throw new Error(); }` |\n\n#### Key Concepts\n\n**Type Safety:** TypeScript helps you avoid mistakes by ensuring you don't assign a value of the wrong type to a variable.\n```typescript\nlet name: string = \"Alice\";\n// ERROR: Type 'number' is not assignable to type 'string'.\nname = 123;\n```\n\n**`any` vs. `unknown`:**\n*   With `any`, you can perform any operation without checks, which is risky.\n*   With `unknown`, TypeScript forces you to narrow the type before you can use it, which is much safer.\n```typescript\nlet value: unknown = \"hello world\";\n\n// ERROR: 'value' is of type 'unknown'.\n// value.toUpperCase();\n\nif (typeof value === \"string\") {\n  // OK: TypeScript now knows 'value' is a string in this block.\n  console.log(value.toUpperCase());\n}\n```"
      },
      "type-annotations-inference": {
        title: "Type Annotations & Inference",
        content: "### Type Annotations & Inference\n\n*   **Type Annotations:** Explicitly telling TypeScript the type of a variable, function parameter, or return value.\n    ```typescript\n    let age: number = 25;\n    function greet(name: string): string {\n      return `Hello, ${name}!`;\n    }\n    ```\n*   **Type Inference:** TypeScript's ability to automatically deduce the type of a variable based on its initial value or usage. This reduces the need for redundant annotations.\n    ```typescript\n    let count = 10; // TypeScript infers 'count' as number\n    const message = \"Hello\"; // TypeScript infers 'message' as string\n    let numbers = [1, 2, 3]; // TypeScript infers 'numbers' as number[]\n    ```\n    It's best practice to rely on inference when possible and use annotations for clarity or when inference isn't sufficient (e.g., function parameters, complex object shapes)."
      },
      "interfaces-vs-type-aliases": {
        title: "Interfaces vs. Type Aliases",
        content: "### Interfaces vs. Type Aliases\n\nBoth `interface` and `type` aliases are used to define the shape of objects and functions. They are very similar, but have some key differences.\n\n*   **Interfaces:**\n    *   Can be `extended` by other interfaces.\n    *   Can be `implemented` by classes.\n    *   Can be `merged` (declaration merging) if declared multiple times with the same name.\n    ```typescript\n    interface Point {\n      x: number;\n      y: number;\n    }\n\n    interface ZPoint extends Point {\n      z: number;\n    }\n\n    class MyPoint implements Point {\n      x: number;\n      y: number;\n      constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n      }\n    }\n    ```\n*   **Type Aliases:**\n    *   Can define types for primitives, unions, tuples, and intersections, which interfaces cannot.\n    *   Cannot be implemented by classes (though objects conforming to the type can be used). \n    *   Cannot be merged.\n    ```typescript\n    type ID = string | number;\n    type Coords = [number, number];\n\n    type User = {\n      id: ID;\n      name: string;\n    }\n    ```\n\n**When to use which:**\n*   **Prefer `interface`** for defining the shape of objects, especially when you expect it to be extended or implemented by classes.\n*   **Use `type`** when you need to define types for primitives, unions, tuples, or when you need more advanced type manipulation (e.g., conditional types)."
      }
    }
  },
  {
    title: "Advanced Types & Features",
    topics: {
      "union-intersection-types": {
        title: "Union & Intersection Types",
        content: "### Union & Intersection Types\n\n*   **Union Types (`|`):** Allows a variable to be one of several types. The value can be *either* `A` *or* `B`.\n    ```typescript\n    type Status = \"active\" | \"inactive\" | \"pending\";\n    let userStatus: Status = \"active\";\n\n    function printID(id: number | string) {\n      console.log(`Your ID is: ${id}`);\n    }\n    printID(101);\n    printID(\"202\");\n    ```\n*   **Intersection Types (`&`):** Combines multiple types into one. The value must have *all* properties of `A` *and* `B`.\n    ```typescript\n    interface Draggable {\n      drag(): void;\n    }\n\n    interface Resizable {\n      resize(): void;\n    }\n\n    type UIWidget = Draggable & Resizable;\n\n    let widget: UIWidget = {\n      drag: () => { console.log(\"Dragging\"); },\n      resize: () => { console.log(\"Resizing\"); }\n    };\n    ```"
      },
      "generics": {
        title: "Generics",
        content: "### Generics\n\nGenerics provide a way to create reusable components that can work with a variety of types, rather than a single one. They allow you to write flexible functions and classes that maintain type safety.\n\n*   **Generic Functions:**\n    ```typescript\n    function identity<T>(arg: T): T {\n      return arg;\n    }\n\n    let output1 = identity<string>(\"myString\"); // type of output1 is string\n    let output2 = identity(100); // type of output2 is number (type inference)\n    ```\n*   **Generic Interfaces/Types:**\n    ```typescript\n    interface Box<T> {\n      value: T;\n    }\n\n    let stringBox: Box<string> = { value: \"hello\" };\n    let numberBox: Box<number> = { value: 123 };\n    ```\n*   **Generic Classes:**\n    ```typescript\n    class GenericNumber<T> {\n      zeroValue: T;\n      add: (x: T, y: T) => T;\n\n      constructor(zeroValue: T, addFunction: (x: T, y: T) => T) {\n        this.zeroValue = zeroValue;\n        this.add = addFunction;\n      }\n    }\n\n    let myGenericNumber = new GenericNumber<number>(0, (x, y) => x + y);\n    console.log(myGenericNumber.add(5, 10)); // 15\n    ```"
      },
      "enums": {
        title: "Enums",
        content: "### Enums\n\nEnums (enumerations) allow you to define a set of named constants. They make it easier to document intent, or create a set of distinct cases.\n\n*   **Numeric Enums (default):**\n    ```typescript\n    enum Direction {\n      Up,    // 0\n      Down,  // 1\n      Left,  // 2\n      Right  // 3\n    }\n\n    let go: Direction = Direction.Up;\n    console.log(go); // 0\n    console.log(Direction[0]); // \"Up\"\n    ```\n*   **String Enums:**\n    ```typescript\n    enum HttpStatus {\n      OK = \"OK\",\n      NotFound = \"NOT_FOUND\",\n      InternalServerError = \"INTERNAL_SERVER_ERROR\"\n    }\n\n    let status: HttpStatus = HttpStatus.OK;\n    console.log(status); // \"OK\"\n    ```\n\n**When to use:** When you have a collection of related constants that represent a fixed set of values."
      },
      "type-guards-narrowing": {
        title: "Type Guards & Narrowing",
        content: "### Type Guards & Narrowing\n\n**Type Narrowing** is the process of refining types to be more specific than what was initially declared. **Type Guards** are special checks that trigger type narrowing.\n\n*   **`typeof` Type Guard:** Useful for primitives (`string`, `number`, `boolean`, `symbol`, `bigint`, `undefined`, `object`, `function`).\n    ```typescript\n    function printLength(obj: string | string[]) {\n      if (typeof obj === \"string\") {\n        console.log(obj.length); // obj is narrowed to string\n      } else {\n        console.log(obj.length); // obj is narrowed to string[]\n      }\n    }\n    ```\n*   **`instanceof` Type Guard:** Used for narrowing custom types (classes). Checks if an object is an instance of a class.\n    ```typescript\n    class Dog { bark() { console.log(\"Woof!\"); } }\n    class Cat { meow() { console.log(\"Meow!\"); } }\n\n    function makeSound(animal: Dog | Cat) {\n      if (animal instanceof Dog) {\n        animal.bark(); // animal is narrowed to Dog\n      } else {\n        animal.meow(); // animal is narrowed to Cat\n      }\n    }\n    ```\n*   **Truthiness Narrowing:** `if` statements can narrow types based on truthiness.\n    ```typescript\n    function processInput(input: string | null | undefined) {\n      if (input) {\n        console.log(input.toUpperCase()); // input is narrowed to string\n      } else {\n        console.log(\"No input\"); // input is narrowed to null | undefined\n      }\n    }\n    ```\n*   **Equality Narrowing:** Using `==`, `===`, `!=`, `!==` can narrow types.\n    ```typescript\n    type A = { a: number; type: \"A\" };\n    type B = { b: number; type: \"B\" };\n\n    function process(item: A | B) {\n      if (item.type === \"A\") {\n        console.log(item.a); // item is narrowed to A\n      } else {\n        console.log(item.b); // item is narrowed to B\n      }\n    }\n    ```"
      },
      "utility-types": {
        title: "Utility Types",
        content: "### Utility Types\n\nTypeScript provides several built-in utility types to facilitate common type transformations.\n\n*   **`Partial<T>`:** Makes all properties of `T` optional.\n    ```typescript\n    interface Todo {\n      title: string;\n      description: string;\n    }\n\n    function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\n      return { ...todo, ...fieldsToUpdate };\n    }\n\n    const todo1: Todo = { title: \"organize desk\", description: \"clear clutter\" };\n    const todo2 = updateTodo(todo1, { description: \"throw out trash\" });\n    // todo2 is { title: \"organize desk\", description: \"throw out trash\" }\n    ```\n*   **`Readonly<T>`:** Makes all properties of `T` `readonly`.\n    ```typescript\n    interface User {\n      name: string;\n      age: number;\n    }\n\n    let readonlyUser: Readonly<User> = { name: \"John\", age: 30 };\n    // readonlyUser.age = 31; // Error: Cannot assign to 'age' because it is a read-only property.\n    ```\n*   **`Pick<T, K>`:** Constructs a type by picking the set of properties `K` from `T`.\n    ```typescript\n    interface Product {\n      id: number;\n      name: string;\n      price: number;\n      description: string;\n    }\n\n    type ProductSummary = Pick<Product, \"name\" | \"price\">;\n    const item: ProductSummary = { name: \"Laptop\", price: 1200 };\n    ```\n*   **`Omit<T, K>`:** Constructs a type by omitting the set of properties `K` from `T`.\n    ```typescript\n    interface Task {\n      id: number;\n      description: string;\n      completed: boolean;\n      createdAt: Date;\n    }\n\n    type NewTask = Omit<Task, \"id\" | \"completed\" | \"createdAt\">;\n    const newTask: NewTask = { description: \"Buy groceries\" };\n    ```"
      }
    }
  },
  {
    title: "Object-Oriented TypeScript",
    topics: {
      "classes": {
        title: "Classes",
        content: "### Classes\n\nTypeScript enhances JavaScript classes by adding features like access modifiers and parameter properties.\n\n*   **Access Modifiers (`public`, `private`, `protected`):**\n    *   `public`: (Default) Accessible everywhere.\n    *   `private`: Only accessible within the class itself.\n    *   `protected`: Accessible within the class and by subclasses.\n    ```typescript\n    class Animal {\n      public name: string;\n      private age: number;\n      protected species: string;\n\n      constructor(name: string, age: number, species: string) {\n        this.name = name;\n        this.age = age;\n        this.species = species;\n      }\n\n      public getAge() {\n        return this.age; // Accessible within the class\n      }\n    }\n\n    class Dog extends Animal {\n      constructor(name: string, age: number) {\n        super(name, age, \"Canine\");\n        console.log(this.species); // Accessible in subclass\n      }\n    }\n\n    const myDog = new Dog(\"Buddy\", 5);\n    console.log(myDog.name); // Buddy (public)\n    // console.log(myDog.age); // Error: Property 'age' is private\n    ```\n*   **Parameter Properties:** A shorthand for declaring and initializing properties in the constructor.\n    ```typescript\n    class Car {\n      constructor(public brand: string, private year: number) {}\n\n      getDetails() {\n        return \\`\\${this.brand} (\\${this.year})\\`;\n      }\n    }\n\n    const myCar = new Car(\"Toyota\", 2020);\n    console.log(myCar.brand); // Toyota\n    // console.log(myCar.year); // Error: Property 'year' is private\n    ```"
      },
      "interfaces-for-classes": {
        title: "Interfaces: Implementing Classes",
        content: "### Interfaces: Implementing Classes\n\nInterfaces can be used to enforce that a class adheres to a certain contract, ensuring it has specific properties and methods.\n\n```typescript\ninterface Greetable {\n  name: string;\n  greet(phrase: string): void;\n}\n\nclass Person implements Greetable {\n  name: string;\n  age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet(phrase: string) {\n    console.log(\\`\\${phrase} \\${this.name}\\`);\n  }\n}\n\nconst user1 = new Person(\"Max\", 30);\nuser1.greet(\"Hi there, I am\"); // Hi there, I am Max\n```\n\n**Key points:**\n*   A class can implement multiple interfaces.\n*   Interfaces only describe the public side of the class instance, not the constructor or static members."
      }
    }
  },
  {
    title: "Configuration & Practical Usage",
    topics: {
      "tsconfig-json": {
        title: "tsconfig.json",
        content: "### tsconfig.json\n\nThe `tsconfig.json` file in a TypeScript project specifies the root files and the compiler options required to compile the project. It's crucial for configuring how TypeScript behaves.\n\n**Key Compiler Options:**\n*   `target`: Specifies the ECMAScript target version (e.g., `\"ES2020\"`, `\"ESNext\"`).\n*   `module`: Specifies the module code generation (e.g., `\"ESNext\"`, `\"CommonJS\"`).\n*   `lib`: Specifies a list of library files to be included in the compilation (e.g., `\"ES2020\"`, `\"DOM\"`).\n*   `jsx`: Specifies the JSX factory to use (e.g., `\"react-jsx\"`).\n*   `strict`: Enables a broad range of strict type-checking options (highly recommended). \n*   `esModuleInterop`: Enables compatibility with CommonJS modules.\n*   `forceConsistentCasingInFileNames`: Disallow inconsistently-cased references to the same file.\n*   `skipLibCheck`: Skip type checking of all declaration files (e.g., `*.d.ts`).\n*   `outDir`: Redirect output structure to the directory.\n*   `rootDir`: Specify the root directory of input files.\n\n**Example `tsconfig.json` (simplified):**\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"skipLibCheck\": true,\n\n    /* Bundler mode */\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\",\n\n    /* Linting */\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true\n  },\n  \"include\": [\"src\"]\n}\n```"
      },
      "modules": {
        title: "Modules",
        content: "### Modules\n\nTypeScript supports both ES Modules (`import`/`export`) and CommonJS (`require`/`module.exports`). In modern TypeScript development, ES Modules are preferred.\n\n*   **Exporting:**\n    ```typescript\n    // math.ts\n    export function add(a: number, b: number): number {\n      return a + b;\n    }\n\n    export const PI = 3.14159;\n\n    export default class Calculator {\n      // ...\n    }\n    ```\n*   **Importing:**\n    ```typescript\n    // app.ts\n    import { add, PI } from \"./math\";\n    import Calculator from \"./math\";\n\n    console.log(add(5, 2));\n    console.log(PI);\n    const calc = new Calculator();\n    ```\n\n**Module Resolution:** TypeScript needs to know how to resolve module imports. This is configured in `tsconfig.json` using options like `moduleResolution` (e.g., `\"node\"` or `\"bundler\"`)."
      },
      "declaration-files": {
        title: "Declaration Files (.d.ts)",
        content: "### Declaration Files (.d.ts)\n\nDeclaration files (`.d.ts`) provide type information for JavaScript code. They allow TypeScript to understand the types of variables, functions, and classes defined in existing JavaScript libraries, even if those libraries aren't written in TypeScript.\n\n*   **Purpose:** To enable type checking, autocompletion, and other TypeScript benefits for JavaScript code without rewriting the JavaScript itself.\n*   **How they work:** They contain only type declarations (interfaces, types, function signatures) and no implementation code.\n*   **Getting declaration files:**\n    *   **Bundled with library:** Many modern JavaScript libraries include their `.d.ts` files directly in their npm package.\n    *   **`@types/` packages:** For libraries that don't include their own, you can often find community-maintained type definitions on npm, usually in the `@types/` scope (e.g., `npm install @types/react`).\n    *   **Manual creation:** You can write your own `.d.ts` files for custom JavaScript code or older libraries.\n\n**Example `my-library.d.ts`:**\n```typescript\ndeclare module \"my-library\" {\n  export function doSomething(arg: string): number;\n  export class MyClass {\n    constructor(name: string);\n    getValue(): string;\n  }\n  export interface MyOptions {\n    enabled: boolean;\n    timeout?: number;\n  }\n}\n\nThis allows you to use `import { doSomething, MyClass } from \"my-library\";` in your TypeScript code with full type safety."
      }
    }
  }
];