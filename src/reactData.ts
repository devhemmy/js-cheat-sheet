export const reactTopics = [
  {
    title: 'Core Fundamentals',
    topics: {
      jsx: {
        title: 'JSX',
        content:
          "### JSX (JavaScript XML)\n\nJSX is a syntax extension for JavaScript that lets you write HTML-like markup inside a JavaScript file. Although React can be used without it, most developers prefer the conciseness and readability of JSX.\n\nUnder the hood, tools like Babel transpile JSX into regular JavaScript function calls to `React.createElement()`.\n\n**Example:**\n\nThis JSX code:\n```jsx\nconst element = <h1 className=\"greeting\">Hello, world!</h1>;\n```\nIs transpiled into this JavaScript:\n```js\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n\n---\n\n#### 1. Key Differences from HTML\n\nWhile it looks like HTML, JSX has stricter rules.\n\n*   **Single Root Element:** A component must return a single parent element. You can use a `<div>` or a Fragment (`<>...</>`) to wrap multiple elements.\n*   **Closing Tags:** All tags must be closed. Self-closing tags like `<img>` must be written as `<img />`.\n*   **camelCase Attributes:** JSX attributes use camelCase naming conventions instead of standard HTML attribute names. For example, `class` becomes `className` and `tabindex` becomes `tabIndex`. This is because `class` is a reserved keyword in JavaScript.\n\n---\n\n#### 2. Embedding JavaScript Expressions\n\nYou can embed any valid JavaScript expression within JSX by wrapping it in curly braces `{}`. This allows you to display dynamic data.\n\nThis can be a variable, a function call, or any other expression that resolves to a value.\n\n**Example:**\n```jsx\nconst name = 'John Doe';\nconst element = <h1>Hello, {name}</h1>; \n// Renders: <h1>Hello, John Doe</h1>\n\nfunction formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n\nconst userElement = <h1>Hello, {formatName(user)}!</h1>;\n// Renders: <h1>Hello, Jane Doe!</h1>\n```\n\n---\n\n#### 3. Attributes in JSX\n\nYou can use quotes for string values or curly braces for JavaScript expressions as attributes.\n\n**Example:**\n```jsx\n// String literal\nconst element1 = <a href=\"https://www.example.com\">Visit our site</a>;\n\n// JavaScript expression\nconst user = {\n  avatarUrl: 'https://www.example.com/avatar.jpg'\n};\nconst element2 = <img src={user.avatarUrl} />;\n```",
      },
      components: {
        title: 'Components (Functional vs. Class)',
        content:
          "### Components (Functional vs. Class)\n\nComponents are the core building blocks of any React application. They are independent, reusable pieces of code that define a part of the user interface. There are two main types: Functional and Class components.\n\nModern React exclusively uses Functional Components with Hooks. Class components are considered legacy but are still present in older codebases.\n\n---\n\n#### 1. Functional Components\n\nA Functional Component is a simple JavaScript function that accepts an object of properties (`props`) as an argument and returns a React element (JSX).\n\n*   **Syntax:** Plain JavaScript function.\n*   **State:** Managed using the `useState` Hook.\n*   **Side Effects:** Handled with the `useEffect` Hook (e.g., API calls, subscriptions).\n*   **Simplicity:** Less code, easier to read, and no `this` keyword to manage.\n\n**Example:**\n```jsx\nimport React, { useState } from 'react';\n\nfunction Greeting(props) {\n  const [name, setName] = useState('World');\n\n  return <h1>Hello, {props.message} {name}!</h1>;\n}\n```\n\n---\n\n#### 2. Class Components (Legacy)\n\nA Class Component is an ES6 class that extends `React.Component` and must include a `render()` method that returns JSX.\n\n*   **Syntax:** ES6 class.\n*   **State:** Managed with `this.state` and updated with `this.setState()`.\n*   **Side Effects:** Handled with lifecycle methods like `componentDidMount()` and `componentDidUpdate()`.\n*   **Complexity:** More boilerplate code and requires understanding the `this` keyword.\n\n**Example:**\n```jsx\nimport React from 'react';\n\nclass Greeting extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: 'World' };\n  }\n\n  render() {\n    return <h1>Hello, {this.props.message} {this.state.name}!</h1>;\n  }\n}\n```\n\n---\n\n#### Quick Comparison\n\n| Feature | Functional Component | Class Component (Legacy) |\n| :--- | :--- | :--- |\n| **Syntax** | JavaScript function | ES6 class |\n| **State** | `useState()` Hook | `this.state` / `this.setState()` |\n| **Side Effects** | `useEffect()` Hook | Lifecycle Methods |\n| **`this` Keyword** | Not needed | Required for state and props |\n| **Recommendation** | The modern standard | Legacy; avoid in new code |\n\n**Best Practice:** Always use Functional Components with Hooks for new development. They are more concise and align with the current direction of the React library.",
      },
      props: {
        title: 'Props',
        content:
          "### Props (Properties)\n\nProps are how you pass data from a parent component down to a child component. They are read-only, meaning a child component should never change the props it receives.\n\nThink of them as arguments to a function or attributes to an HTML tag.\n\n---\n\n#### 1. Passing and Accessing Props\n\nYou pass props to a component as attributes in JSX. The child component then receives these props as a single object argument.\n\n**Example:**\n\n**Parent Component (App.js)**\n\nThe `App` component passes a `name` and `message` prop to the `Welcome` component.\n```jsx\nimport React from 'react';\nimport Welcome from './Welcome';\n\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"Alice\" message=\"Welcome to React!\" />\n      <Welcome name=\"Bob\" message=\"Have a great day.\" />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n**Child Component (Welcome.js)**\n\nThe `Welcome` component receives the `props` object and uses its values.\n```jsx\nimport React from 'react';\n\n// The 'props' object contains 'name' and 'message'\nfunction Welcome(props) {\n  return (\n    <h1>{props.message}, {props.name}</h1>\n  );\n}\n\nexport default Welcome;\n```\n\n**Result:**\n\nThe screen will display:\n```\nWelcome to React!, Alice\nHave a great day., Bob\n```\n\n---\n\n#### 2. Destructuring Props\n\nTo make your code cleaner, it's common to destructure the `props` object directly in the function's parameter list.\n\nThis avoids repeating `props.` everywhere.\n\n**Example (destructured):**\n```jsx\n// Instead of function Welcome(props)\nfunction Welcome({ name, message }) {\n  return (\n    <h1>{message}, {name}</h1>\n  );\n}\n```\n\n---\n\n#### Key Rules of Props\n\n*   **Read-Only:** A component must never modify its own props. All React components must act like pure functions with respect to their props. This is a core principle of React.\n*   **Data Flows Down:** Data in props always flows in one direction: from parent to child.\n\n**Best Practice:** Use props to configure and customize child components, making them reusable and dynamic.",
      },
      state: {
        title: 'State',
        content:
          '### State\n\nState is data that a component "owns" and can change over time. Unlike props, which are passed in from a parent, state is managed inside the component itself.\n\nWhen a component\'s state changes, React automatically re-renders the component to reflect the new data. This is the core mechanism for creating interactive user interfaces.\n\n---\n\n#### 1. The useState Hook\n\nIn modern functional components, you add state using the `useState` Hook.\n\n`useState` is a function that returns an array with two elements:\n\n*   The current state value.\n*   A function to update that value.\n\n**Syntax:**\n```jsx\nimport { useState } from \'react\';\n\nconst [stateVariable, setStateFunction] = useState(initialValue);\n```\n\n---\n\n#### 2. How State Works\n\n*   **Initialization:** You give `useState` an initial value (e.g., a number, string, boolean). This is the value the state will have on the first render.\n*   **Reading State:** You use the state variable (`stateVariable`) directly in your JSX to display it.\n*   **Updating State:** You must use the setter function (`setStateFunction`) to change the state. Calling this function tells React that the state has changed and it needs to re-render the component.\n\n> **Important:** Never modify state directly (e.g., `count = count + 1`). This will not trigger a re-render and can lead to bugs.\n\n---\n\n#### Example: A Simple Counter\n\nThis component has a `count` state. Clicking the button calls `setCount`, which updates the state and causes the component to re-render with the new count.\n\n```jsx\nimport React, { useState } from \'react\';\n\nfunction Counter() {\n  // 1. Initialize state: \'count\' starts at 0\n  const [count, setCount] = useState(0);\n\n  function increment() {\n    // 3. Update state using the setter function\n    setCount(count + 1);\n  }\n\n  return (\n    <div>\n      {/* 2. Read and display the current state */}\n      <p>You clicked {count} times</p>\n      <button onClick={increment}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n---\n\n#### Key Principles of State\n\n*   **Local and Private:** State is encapsulated within the component that defines it.\n*   **Triggers Re-renders:** The only way to update the UI is by changing state.\n*   **Asynchronous Updates:** State updates may be batched by React for performance, so you shouldn\'t rely on the new state value immediately after setting it.',
      },
      'virtual-dom': {
        title: 'Virtual DOM',
        content:
          '### Virtual DOM\n\nThe Virtual DOM (VDOM) is a programming concept where a lightweight copy of the real browser DOM is kept in memory and managed by a library like React. It is one of the key reasons for React\'s high performance.\n\nInstead of directly manipulating the slow browser DOM for every change, React works with this much faster, in-memory representation.\n\n---\n\n#### 1. How It Works: The Reconciliation Process\n\nThe process of using the Virtual DOM to update the real DOM is called reconciliation. It follows these steps:\n\n*   **State Change Occurs:** When a component\'s state or props change, React creates a new Virtual DOM tree.\n*   **Diffing:** React then compares this new VDOM tree with the previous one. This comparison process is called "diffing." React\'s algorithm is highly optimized to find the minimal number of changes between the two trees.\n*   **Batch Updates:** React collects all the identified changes and updates the real browser DOM in a single, efficient batch operation.\n\nBy updating only the elements that have actually changed, React avoids expensive and unnecessary manipulations of the real DOM.\n\n**In short:**\nState changes ➝ New VDOM is created ➝ VDOM is "diffed" with the old one ➝ Minimal changes are applied to the real DOM.\n\n---\n\n#### 2. Why Is This Faster?\n\nManipulating the real DOM is slow. Every time you change an element, the browser may have to recalculate the layout and repaint the screen ("reflow" and "repaint"), which are computationally expensive operations.\n\nThe Virtual DOM is just a JavaScript object, so reading from it and writing to it is incredibly fast. By batching the updates and applying only the necessary changes to the real DOM, React significantly reduces the number of slow browser operations.\n\n---\n\n#### Key Benefits\n\n*   **Performance:** Drastically reduces the number of direct manipulations to the real DOM, making UI updates much faster.\n*   **Simplified Development:** Developers can write code declaratively, describing what the UI should look like for a given state, and React handles the complex task of efficiently updating the DOM.\n*   **Cross-Platform:** The Virtual DOM is not tied to the browser. This abstraction allows React to be used in other environments, like mobile app development with React Native.',
      },
    },
  },
  {
    title: 'Component Lifecycle & Rendering',
    topics: {
      'component-lifecycle': {
        title: 'Component Lifecycle',
        content:
          '### Component Lifecycle\n\nEvery React component goes through a lifecycle of events from its creation to its removal from the DOM. This lifecycle is divided into three main phases: Mounting, Updating, and Unmounting.\n\nUnderstanding the lifecycle allows you to perform actions at specific moments, like fetching data when a component first appears or cleaning up resources before it disappears.\n\nIn modern React, the `useEffect` Hook is used to handle all lifecycle events in functional components. Class components use specific lifecycle methods, which are now considered legacy.\n\n---\n\n#### 1. Mounting: The Component is Born\n\nThis phase occurs when a component is being created and inserted into the DOM for the first time.\n\n*   **What it\'s for:** Initial setup, fetching data from an API, or setting up subscriptions.\n*   **`useEffect` Equivalent:** An effect that runs only once. You achieve this with an empty dependency array (`[]`).\n\n**Example (`useEffect`)**\n```jsx\nimport React, { useState, useEffect } from \'react\';\n\nfunction MyComponent() {\n  const [data, setData] = useState(null);\n\n  // This runs once, after the component mounts\n  useEffect(() => {\n    console.log("Component has mounted!");\n    // Common use: Fetch initial data\n    // fetch(\'api/data\').then(res => setData(res.json()));\n  }, []); // Empty array means "run only on mount"\n\n  return <div>My Component</div>;\n}\n```\n\n---\n\n#### 2. Updating: The Component Changes\n\nThis phase occurs whenever a component\'s state or props change, causing it to re-render.\n\n*   **What it\'s for:** Responding to changes in props or state, and performing side effects only when specific data has changed.\n*   **`useEffect` Equivalent:** An effect with dependencies. The effect function will re-run only if the values in the dependency array have changed since the last render.\n\n**Example (`useEffect`)**\n```jsx\nimport React, { useState, useEffect } from \'react\';\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n\n  // This effect runs when the component mounts AND\n  // anytime the \'userId\' prop changes.\n  useEffect(() => {\n    console.log(`User ID changed to: ${userId}. Fetching new data...`);\n    // fetch(`api/users/${userId}`).then(res => setUser(res.json()));\n  }, [userId]); // Dependency array watches \'userId\' for changes\n\n  return <div>Viewing profile for user {userId}</div>;\n}\n```\n\n---\n\n#### 3. Unmounting: The Component Dies\n\nThis is the final phase, where the component is being removed from the DOM.\n\n*   **What it\'s for:** Cleaning up to prevent memory leaks. This includes canceling timers, stopping API subscriptions, or removing event listeners.\n*   **`useEffect` Equivalent:** The cleanup function. If you return a function from your `useEffect` callback, React will run it right before the component unmounts.\n\n**Example (`useEffect`)**\n```jsx\nimport React, { useEffect } from \'react\';\n\nfunction Timer() {\n  useEffect(() => {\n    // Side effect: start a timer\n    const intervalId = setInterval(() => {\n      console.log(\'Timer tick...\');\n    }, 1000);\n\n    // Return a cleanup function\n    return () => {\n      console.log("Component is unmounting. Clearing timer.");\n      clearInterval(intervalId); // This prevents memory leaks\n    };\n  }, []); // Empty array ensures this runs only on mount and unmount\n\n  return <div>I have a timer running in the console.</div>;\n}\n',
      },
      'conditional-rendering': {
        title: 'Conditional Rendering',
        content:
          '### Conditional Rendering\n\nConditional rendering allows you to display different components or UI elements based on certain conditions. This is how you make your application dynamic—showing a loading spinner, a welcome message for a logged-in user, or an error notification.\n\nIn React, you use standard JavaScript syntax to control what gets rendered. The most common approaches are the ternary operator and the logical `&&` operator.\n\n---\n\n#### 1. Ternary Operator (`? :`) for If-Else Logic\n\nThe ternary operator is a compact way to write an if-else statement directly within your JSX. It\'s best used when you need to render one thing if a condition is true, and a different thing if it\'s false.\n\n**Syntax:**\n`condition ? (expression_if_true) : (expression_if_false)`\n\n**Example: User Greeting**\nThis component shows a "Welcome back!" message if the user is logged in, and a "Please sign in" message otherwise.\n```jsx\nimport React from \'react\';\n\nfunction UserGreeting({ isLoggedIn }) {\n  return (\n    <div>\n      {isLoggedIn ? (\n        <h1>Welcome back!</h1>\n      ) : (\n        <h1>Please sign in.</h1>\n      )}\n    </div>\n  );\n}\n\n// How to use it:\n// <UserGreeting isLoggedIn={true} />  // Renders "Welcome back!"\n// <UserGreeting isLoggedIn={false} /> // Renders "Please sign in."\n```\n\n---\n\n#### 2. Logical `&&` Operator for If Logic\n\nThe logical AND (`&&`) operator is a concise way to render an element only if a certain condition is true. If the condition is false, it renders nothing.\n\nThis works because in JavaScript, `true && expression` always evaluates to `expression`, while `false && expression` always evaluates to `false`. React doesn\'t render `false`, `null`, or `undefined`.\n\n**Syntax:**\n`condition && (expression_if_true)`\n\n**Example: Notification Badge**\nThis component displays a notification count only if there are unread messages.\n```jsx\nimport React from \'react\';\n\nfunction Mailbox({ unreadMessages }) {\n  const messageCount = unreadMessages.length;\n\n  return (\n    <div>\n      <h1>Hello!</h1>\n      {messageCount > 0 && (\n        <h2>\n          You have {messageCount} unread messages.\n        </h2>\n      )}\n    </div>\n  );\n}\n\n// How to use it:\n// <Mailbox unreadMessages={[\'msg1\', \'msg2\']} /> // Renders the h2\n// <Mailbox unreadMessages={[]} />              // Renders only the h1\n```\n\n---\n\n#### 3. Using `if` Statements with Variables\n\nWhen your logic is too complex for a ternary operator, you can use a standard `if` statement to assign a component or JSX to a variable, and then render that variable. This keeps your return statement clean.\n\n**Example: Login/Logout Button**\n```jsx\nimport React, { useState } from \'react\';\n\nfunction LoginControl() {\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n\n  let button;\n\n  if (isLoggedIn) {\n    button = <button onClick={() => setIsLoggedIn(false)}>Logout</button>;\n  } else {\n    button = <button onClick={() => setIsLoggedIn(true)}>Login</button>;\n  }\n\n  return (\n    <div>\n      {/* Render the button determined by the if statement */}\n      {button}\n    </div>\n  );\n}\n',
      },
      'lists-and-keys': {
        title: 'Lists and Keys',
        content:
          '### Lists and Keys\n\nTo render a dynamic list of elements in React, you typically use JavaScript array methods like `.map()` to transform an array of data into an array of JSX elements.\n\nWhen you do this, you must provide a special prop called `key` for each item in the list.\n\n---\n\n#### 1. Rendering Lists with `.map()`\n\nThe `.map()` method is the standard way to render a list. It creates a new array by calling a function on every element in the original array. In React, you use it to map your data array to a component array.\n\n**Example: Rendering a list of numbers**\n```jsx\nimport React from \'react\';\n\nfunction NumberList({ numbers }) {\n  // Map the array of numbers to an array of <li> elements\n  const listItems = numbers.map((number) =>\n    <li key={number.toString()}>\n      {number}\n    </li>\n  );\n\n  return <ul>{listItems}</ul>;\n}\n\n// How to use it:\n// const numbers = [1, 2, 3, 4, 5];\n// <NumberList numbers={numbers} />\n```\n\n---\n\n#### 2. The Importance of the `key` Prop\n\nA `key` is a special string attribute you need to include when creating lists of elements. Keys help React identify which items have changed, are added, or are removed.\n\n*   **What it does:** Keys give each element in a list a stable identity. This allows React\'s diffing algorithm to quickly and efficiently track items between re-renders.\n*   **Why it\'s needed:** Without keys, React may have to re-render the entire list if its order changes, which is inefficient and can lead to bugs with component state.\n\n**Rules for Keys:**\n\n*   **Unique Among Siblings:** Keys only need to be unique among their siblings in the same array. They don\'t have to be globally unique.\n*   **Stable and Predictable:** A key should not change between renders. The best keys are unique and stable IDs from your data (like a database ID, `user.id`, `product.sku`).\n\n**Example: Using data IDs as keys**\n```jsx\nconst todos = [\n  { id: \'abc\', text: \'Learn React\' },\n  { id: \'def\', text: \'Build a project\' },\n];\n\nconst todoItems = todos.map((todo) =>\n  <li key={todo.id}>\n    {todo.text}\n  </li>\n);\n```\n\n---\n\n#### 3. Why You Should Avoid Using the Array Index as a `key`\n\nUsing the array index as a key is an anti-pattern, especially if the list can be reordered, filtered, or have items added/removed from the beginning or middle.\n\n`key={index}`\n\n*   **The Problem:** The index of an item is not stable. If you add a new item to the beginning of the array, all the following items get a new index. React sees the changed key and can get confused, leading to incorrect UI rendering and state management issues.\n\n*   **When is index as a key acceptable?**\n    It\'s only safe if all of the following are true:\n    *   The list is static and will never change.\n    *   The items in the list have no unique IDs.\n    *   The list will never be reordered or filtered.\n\n**Best Practice:** Always use a stable, unique ID from your data as the key. If you don\'t have one, you should consider adding one (e.g., using a library like `uuid`).',
      },
    },
  },
  {
    title: 'Hooks',
    topics: {
      useState: {
        title: 'useState',
        content:
          '### `useState` Hook\n\nThe `useState` Hook is the most fundamental and commonly used Hook in React. It allows you to add a state variable to your functional components.\n\nIt provides a way for your component to "remember" information between renders. When the state changes, React re-renders the component.\n\n---\n\n#### 1. How to Use `useState`\n\nFirst, you import it from React. Then, you call it inside your functional component to create a single piece of state.\n\n`useState(initialState)` takes one argument: the initial value of the state.\n\nIt returns an array containing two elements:\n\n*   The current state value.\n*   The setter function to update this value.\n\nYou typically use array destructuring to get these two values.\n\n**Syntax:**\n```jsx\nimport React, { useState } from \'react\';\n\nconst [state, setState] = useState(initialValue);\n```\n\n---\n\n#### 2. Example: A Simple Toggle\n\nThis component uses `useState` to manage a boolean `isOn` state. Clicking the button calls the `setIsOn` function, which updates the state and triggers a re-render.\n\n```jsx\nimport React, { useState } from \'react\';\n\nfunction ToggleSwitch() {\n  // 1. Declare state variable \'isOn\', initialized to \'false\'\n  const [isOn, setIsOn] = useState(false);\n\n  const handleToggle = () => {\n    // 3. Use the setter function to update the state\n    setIsOn(!isOn);\n  };\n\n  return (\n    <div>\n      {/* 2. Read the state value to determine what to display */}\n      <p>The switch is {isOn ? \'ON\' : \'OFF\'}</p>\n      <button onClick={handleToggle}>\n        Toggle\n      </button>\n    </div>\n  );\n}\n```\n\n---\n\n#### 3. Updating State Based on the Previous State\n\nIf your new state depends on the previous state value, you should pass a function to the setter. This function receives the previous state as an argument and returns the new state.\n\nThis is the safest way to update state and avoids potential bugs caused by asynchronous updates.\n\n**The Wrong Way (can be buggy):**\n```jsx\nfunction increment() {\n  // If React batches updates, \'count\' might not be the latest value here\n  setCount(count + 1);\n}\n```\n\n**The Correct Way (using a function):**\n```jsx\nfunction increment() {\n  // This guarantees \'prevCount\' is the latest state value\n  setCount(prevCount => prevCount + 1);\n}\n```\nThis is especially important when you have multiple state updates in the same function.\n\n---\n\n#### 4. Rules of `useState`\n\n*   **Only call Hooks at the top level:** Don\'t call `useState` inside loops, conditions, or nested functions.\n*   **Only call Hooks from React functions:** Call them from your functional components, not regular JavaScript functions.\n*   **State updates are batched:** React may group multiple `setState` calls into a single re-render for better performance.',
      },
      useEffect: {
        title: 'useEffect',
        content:
          '### `useEffect` Hook\n\nThe `useEffect` Hook lets you perform side effects in functional components. Side effects are operations that interact with the "outside world," meaning anything that isn\'t directly related to calculating what to render.\n\nCommon examples include fetching data, setting up timers or subscriptions, and manually changing the DOM. `useEffect` combines the functionality of `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` from older class components.\n\n---\n\n#### 1. How to Use `useEffect`\n\nYou call `useEffect` at the top level of your component. It takes two arguments:\n\n1.  A setup function where you put your side effect logic.\n2.  An optional dependency array, which controls when the effect is re-run.\n\n**Syntax:**\n```jsx\nimport React, { useEffect } from \'react\';\n\nuseEffect(() => {\n  // Your side effect logic goes here.\n  \n  // Optional: return a cleanup function.\n  return () => {\n    // Cleanup logic goes here.\n  };\n}, [dependencies]);\n```\n\n---\n\n#### 2. The Dependency Array\n\nThe dependency array is crucial for controlling the behavior of your effect.\n\n*   **No dependency array:** The effect runs after every single render. This is often inefficient and can cause infinite loops.\n    ```jsx\n    useEffect(() => {\n      // Runs on mount and every re-render\n    });\n    ```\n\n*   **Empty dependency array (`[]`):** The effect runs only once, right after the component mounts for the first time. This is perfect for initial data fetching or setup.\n    ```jsx\n    useEffect(() => {\n      // Runs only on mount\n    }, []);\n    ```\n\n*   **Array with values (`[prop, state]`):** The effect runs on mount and then only when any value in the array changes between renders. This lets you re-run logic (like fetching new data) when a specific prop or state variable changes.\n    ```jsx\n    useEffect(() => {\n      // Runs on mount and whenever \'userId\' changes\n      fetch(`/api/users/${userId}`);\n    }, [userId]);\n    ```\n\n---\n\n#### 3. The Cleanup Function\n\nTo prevent memory leaks, you can return a function from your effect. This is the cleanup function. React will run it:\n\n*   Before the component unmounts (is removed from the screen).\n*   Before re-running the effect due to a dependency change.\n\nThis is essential for canceling timers, unsubscribing from data sources, or removing event listeners.\n\n**Example: A Timer**\n```jsx\nimport React, { useState, useEffect } from \'react\';\n\nfunction Timer() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    // Side effect: set up the interval\n    const intervalId = setInterval(() => {\n      setSeconds(s => s + 1);\n    }, 1000);\n\n    // Cleanup: clear the interval when the component unmounts\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, []); // [] means this effect runs once on mount\n\n  return <h1>{seconds} seconds have passed.</h1>;\n}\n',
      },
      useContext: {
        title: 'useContext',
        content:
          '### `useContext` Hook\n\nThe `useContext` Hook provides a way to pass data through the component tree without having to pass props down manually at every level. It\'s designed to solve the problem of "prop drilling."\n\n**Prop Drilling:** When you have a deeply nested component that needs data from a component far up the tree, you have to pass that data as props through all the intermediate components, even if they don\'t use it. This can become very cumbersome.\n\n`useContext` allows a parent component to make data available to any component in the tree below it, no matter how deep.\n\n---\n\n#### How to Use `useContext` (in 3 steps)\n\n1.  **Create a Context:** First, create a context object using `React.createContext()`. You can provide a default value, which is used when a component is not wrapped in a provider.\n2.  **Provide the Context:** Wrap your parent component (or the part of your app that needs the data) with the context\'s `Provider` component. The provider accepts a `value` prop, which is the data you want to share.\n3.  **Consume the Context:** In any child component that needs access to the data, call the `useContext()` Hook with the context object you created.\n\n---\n\n#### Example: A Simple Theme Switcher\n\n**Step 1: Create the Context (`ThemeContext.js`)**\nThis file creates and exports the context.\n```jsx\nimport { createContext } from \'react\';\n\n// The context can have any default value. Here, it\'s \'light\'.\nexport const ThemeContext = createContext(\'light\');\n```\n\n**Step 2: Provide the Context (`App.js`)**\nThe `App` component provides the theme value to all components inside the `ThemeContext.Provider`. Any child component can now access this value.\n```jsx\nimport React, { useState } from \'react\';\nimport { ThemeContext } from \'./ThemeContext\';\nimport Toolbar from \'./Toolbar\';\n\nfunction App() {\n  const [theme, setTheme] = useState(\'light\');\n\n  const toggleTheme = () => {\n    setTheme(theme === \'light\' ? \'dark\' : \'light\');\n  };\n\n  return (\n    // Any component inside this provider can access the \'theme\' value\n    <ThemeContext.Provider value={theme}>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\nexport default App;\n```\n\n**Step 3: Consume the Context (`Toolbar.js`)**\nThe `Toolbar` component uses `useContext` to read the current theme value directly from the provider, without needing it passed as a prop.\n```jsx\nimport React, { useContext } from \'react\';\nimport { ThemeContext } from \'./ThemeContext\';\n\nfunction Toolbar() {\n  // Use the useContext hook to get the current value from the provider\n  const theme = useContext(ThemeContext);\n\n  const style = {\n    background: theme === \'dark\' ? \'#333\' : \'#FFF\',\n    color: theme === \'dark\' ? \'#FFF\' : \'#333\',\n    padding: \'20px\',\n    margin: \'20px 0\'\n  };\n\n  return (\n    <div style={style}>\n      Current theme is: {theme}\n    </div>\n  );\n}\n\nexport default Toolbar;\n```\n\n**Result:** The `Toolbar` component\'s background and text color will change when the "Toggle Theme" button is clicked, even though `App` never passed `theme` to it as a prop.',
      },
      useReducer: {
        title: 'useReducer',
        content:
          '### `useReducer` Hook\n\nThe `useReducer` Hook is an alternative to `useState` for managing a component\'s state. It is generally preferred when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.\n\n`useReducer` follows the "reducer" pattern from functional programming (and libraries like Redux). Instead of updating state directly, you dispatch "actions" that describe what happened, and a "reducer function" handles the state logic.\n\n---\n\n#### 1. When to Use `useReducer` vs. `useState`\n\n*   Use `useState` for simple state, like a boolean, a string, or a number.\n*   Use `useReducer` when:\n    *   State logic is complex and involves several operations.\n    *   The state is an object or array with multiple related values.\n    *   The next state depends on the previous state in a non-trivial way.\n    *   You want to optimize performance for components that trigger deep updates.\n\n---\n\n#### 2. How to Use `useReducer`\n\nYou call `useReducer` with a reducer function and an initial state.\n\nIt returns an array with two elements:\n\n*   The current state.\n*   A dispatch function to send actions to the reducer.\n\n**Syntax:**\n```jsx\nimport { useReducer } from \'react\';\n\nconst [state, dispatch] = useReducer(reducer, initialState);\n```\n\n---\n\n#### 3. The Reducer Function\n\nA reducer is a pure function that takes two arguments: the current state and an action object. It calculates and returns the next state.\n\nAn action is an object that describes what happened. It usually has a `type` property (a string) and an optional `payload` (the data).\n\n**Syntax:**\n```javascript\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \'ACTION_TYPE_1\':\n      return { ...state, /* new state values */ };\n    case \'ACTION_TYPE_2\':\n      return { ...state, /* other new values */ };\n    default:\n      return state;\n  }\n}\n```\n\n---\n\n#### Example: A Counter with Increment, Decrement, and Reset\n\nThis shows how `useReducer` can centralize all state logic.\n\n**1. Define the reducer and initial state:**\n```javascript\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \'increment\':\n      return { count: state.count + 1 };\n    case \'decrement\':\n      return { count: state.count - 1 };\n    case \'reset\':\n      return { count: 0 };\n    default:\n      throw new Error();\n  }\n}\n```\n\n**2. Use `useReducer` in the component:**\n```jsx\nimport React, { useReducer } from \'react\';\n\n// (Reducer function and initialState from above)\n\nfunction Counter() {\n  // state will be { count: 0 } initially\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <div>\n      <h1>Count: {state.count}</h1>\n      {/* Dispatch actions on user events */}\n      <button onClick={() => dispatch({ type: \'increment\' })}>+</button>\n      <button onClick={() => dispatch({ type: \'decrement\' })}>-</button>\n      <button onClick={() => dispatch({ type: \'reset\' })}>Reset</button>\n    </div>\n  );\n}\n```\n\n**How it works:**\n\n*   The component displays `state.count`.\n*   When a button is clicked, it calls `dispatch` with an action object (e.g., `{ type: \'increment\' }`).\n*   React sends this action to your reducer function along with the current state.\n*   The reducer calculates the new state based on the action\'s type and returns it.\n*   React re-renders the component with the new state.',
      },
      'custom-hooks': {
        title: 'Custom Hooks',
        content:
          '### Custom Hooks\n\nA Custom Hook is a reusable JavaScript function whose name starts with "use" and that can call other Hooks (like `useState` or `useEffect`).\n\nThey are a core feature of modern React for sharing stateful logic between components without changing your component hierarchy. Instead of using complex patterns like Higher-Order Components (HOCs) or Render Props, you can extract component logic into a simple, reusable function.\n\n---\n\n#### 1. Why Create a Custom Hook?\n\nImagine you have several components that all need to perform the same logic, such as:\n\n*   Fetching data from an API.\n*   Subscribing to a browser event (like window resize).\n*   Managing a complex form state.\n*   Reading from or writing to `localStorage`.\n\nInstead of duplicating this logic in every component, you can extract it into a custom Hook and reuse it easily.\n\n---\n\n#### 2. Creating a Custom Hook\n\nA custom Hook is just a function. The key is that it can use other Hooks internally.\n\n**Example: Creating a `useDocumentTitle` Hook**\nLet\'s create a custom hook that updates the browser\'s document title. This is a common side effect.\n\n**The Logic (inside a component):**\n```jsx\nimport React, { useState, useEffect } from \'react\';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  // This is the logic we want to reuse\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  }, [count]);\n\n  return <button onClick={() => setCount(count + 1)}>Click me</button>;\n}\n```\n\n**Step 1: Extract the logic into a `use...` function.**\nWe create a new file `useDocumentTitle.js`. The function takes the title as an argument.\n```javascript\n// useDocumentTitle.js\nimport { useEffect } from \'react\';\n\nfunction useDocumentTitle(title) {\n  useEffect(() => {\n    document.title = title;\n  }, [title]); // Re-run the effect only if the title changes\n}\n\nexport default useDocumentTitle;\n```\n\n**Step 2: Use the custom Hook in your component.**\nNow, the component becomes much simpler. It just calls the custom Hook to handle the side effect.\n```jsx\nimport React, { useState } from \'react\';\nimport useDocumentTitle from \'./useDocumentTitle\';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  // Use our custom Hook to manage the document title\n  useDocumentTitle(`You clicked ${count} times`);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n---\n\n#### 3. Another Example: `useFetch`\n\nA very common use case is a hook to fetch data. This hook can manage the data, loading state, and error state.\n```javascript\nimport { useState, useEffect } from \'react\';\n\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    setLoading(true);\n    fetch(url)\n      .then((res) => res.json())\n      .then((data) => setData(data))\n      .catch((err) => setError(err))\n      .finally(() => setLoading(false));\n  }, [url]); // Re-fetch if the URL changes\n\n  // Return the state for the component to use\n  return { data, loading, error };\n}\n```\n\n**How to use it:**\n```jsx\nfunction UserProfile({ userId }) {\n  const { data, loading, error } = useFetch(`/api/users/${userId}`);\n\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error!</p>;\n\n  return <div>{data.name}</div>;\n}\n```\n\n**Key Takeaway:** Custom Hooks let you build your own library of reusable, stateful logic that can be easily shared across your entire application, making your components cleaner and more focused on their rendering task.',
      },
    },
  },
  {
    title: 'State Management',
    topics: {
      'lifting-state-up': {
        title: 'Lifting State Up',
        content:
          '### Lifting State Up\n\n"Lifting state up" is a common pattern in React for managing state that needs to be shared between multiple components. Instead of each component keeping its own local state, you move the state up to their closest common ancestor.\n\nThis parent component then becomes the single "source of truth" for that data. It passes the state down to the child components via props, along with functions to update it. This ensures all components are always in sync, reflecting the same data.\n\n---\n\n#### 1. The Problem: Sibling Components Can\'t Communicate\n\nReact\'s data flow is unidirectional (top-down). A parent can pass data to a child via props, but sibling components cannot directly share state or communicate with each other.\n\nImagine a temperature calculator with two inputs: one for Celsius and one for Fahrenheit. If you type a value in the Celsius input, the Fahrenheit input should update, and vice versa. If each input manages its own state, they have no way of knowing about each other\'s changes.\n\n---\n\n#### 2. The Solution: Lifting the State\n\nTo solve this, you identify the shared state (the current temperature) and move it to the closest common ancestor component (`Calculator`).\n\nThe process involves a few steps:\n\n*   **Identify the shared state:** Determine what data multiple components need to access or modify.\n*   **Find the common ancestor:** Locate the nearest parent component that contains all the components needing the state.\n*   **Move the state:** Remove the local state from the child components and add it to the parent using `useState`.\n*   **Pass state down as props:** The parent passes the state value down to the children.\n*   **Pass update functions down as props:** The parent also passes down the function that updates its state (the setter from `useState`), allowing the children to trigger updates in the parent.\n\n---\n\n#### Example: Temperature Calculator\n\n**Before (State is local and not synced):**\nEach `TemperatureInput` has its own `temperature` state. They are independent and don\'t update each other.\n```jsx\nfunction TemperatureInput() {\n  const [temperature, setTemperature] = useState(\'\');\n  // ... render input\n}\n\nfunction Calculator() {\n  return (\n    <div>\n      <TemperatureInput scale="c" />\n      <TemperatureInput scale="f" />\n    </div>\n  );\n}\n```\n\n**After (State is lifted up):**\nThe state is moved to the `Calculator` component.\n\n**Parent Component (`Calculator.js`)**\n```jsx\nimport React, { useState } from \'react\';\nimport TemperatureInput from \'./TemperatureInput\';\n\nfunction Calculator() {\n  // State is lifted here. It is the single source of truth.\n  const [temperature, setTemperature] = useState(\'\');\n  const [scale, setScale] = useState(\'c\');\n\n  const handleCelsiusChange = (temp) => {\n    setTemperature(temp);\n    setScale(\'c\');\n  };\n\n  const handleFahrenheitChange = (temp) => {\n    setTemperature(temp);\n    setScale(\'f\');\n  };\n  \n  // Convert the temperature for the other input\n  const celsius = scale === \'f\' ? (temperature - 32) * 5 / 9 : temperature;\n  const fahrenheit = scale === \'c\' ? (temperature * 9 / 5) + 32 : temperature;\n\n  return (\n    <div>\n      {/* Pass the state and the update function down as props */}\n      <TemperatureInput\n        scale="c"\n        temperature={celsius}\n        onTemperatureChange={handleCelsiusChange} />\n        \n      <TemperatureInput\n        scale="f"\n        temperature={fahrenheit}\n        onTemperatureChange={handleFahrenheitChange} />\n    </div>\n  );\n}\n```\n\n**Child Component (`TemperatureInput.js`)**\nThe child now receives its value and the function to change it from props. It has no local state of its own.\n```jsx\nfunction TemperatureInput({ scale, temperature, onTemperatureChange }) {\n  const handleChange = (e) => {\n    // Calls the parent\'s update function\n    onTemperatureChange(e.target.value);\n  };\n\n  return (\n    <fieldset>\n      <legend>Enter temperature in {scale === \'c\' ? \'Celsius\' : \'Fahrenheit\'}:</legend>\n      {/* The value comes from props */}\n      <input value={temperature} onChange={handleChange} />\n    </fieldset>\n  );\n}\n```\nNow, when you type in one input, it calls the handler function in the `Calculator`. The `Calculator` updates its state, and then re-renders both `TemperatureInput` components with the new, converted values, keeping them perfectly in sync.',
      },
      'context-api': {
        title: 'Context API',
        content:
          '### Context API\n\nThe Context API is React\'s built-in solution for managing global state. It allows you to share state across the entire app (or a large part of it) without "prop drilling"—the tedious process of passing props down through many levels of components.\n\nThink of it as creating a global data store that any component can subscribe to.\n\n---\n\n#### 1. When to Use Context\n\nContext is designed for data that is considered "global" for a tree of React components, such as:\n\n*   **UI Theming:** Sharing a theme (e.g., \'dark\' or \'light\') with all components.\n*   **User Authentication:** Making the current user\'s data available everywhere.\n*   **Application Settings:** Sharing language preferences or other user settings.\n*   **Complex State:** When combined with `useReducer`, it can act as a lightweight alternative to state management libraries like Redux.\n\n> **Important:** Context is not a replacement for passing props. For data that is only needed by a few nested components, "lifting state up" is often a simpler and better solution.\n\n---\n\n#### 2. How It Works\n\nUsing the Context API involves three main steps, which were covered in the `useContext` section:\n\n*   **`React.createContext()`:** You create a Context object. This object is what components will subscribe to.\n    ```javascript\n    export const AuthContext = React.createContext(null);\n    ```\n\n*   **`<Context.Provider>`:** You use the `Provider` component to wrap a part of your component tree. It accepts a `value` prop, which is the data you want to make available to all components underneath it.\n    ```jsx\n    // In your main App or layout component\n    <AuthContext.Provider value={{ currentUser: user }}>\n      <MyApp />\n    </AuthContext.Provider>\n    ```\n\n*   **`useContext(MyContext)`:** Any functional component within the provider\'s tree can now access the shared value by using the `useContext` Hook.\n    ```jsx\n    import { useContext } from \'react\';\n    import { AuthContext } from \'./AuthContext\';\n\n    function UserAvatar() {\n      const { currentUser } = useContext(AuthContext);\n\n      if (!currentUser) return null;\n\n      return <img src={currentUser.avatarUrl} alt={currentUser.name} />;\n    }\n    ```\n\n---\n\n#### Key Characteristics\n\n*   **Avoids Prop Drilling:** Its primary purpose is to make data accessible to deeply nested components without passing it through every intermediate component.\n*   **Performance:** React re-renders all components that consume a context whenever the provider\'s `value` prop changes. This can lead to performance issues if the value changes frequently or the data is very large. For high-frequency updates, other state management solutions might be more suitable.\n*   **Decouples Components:** Components no longer need to know where the data comes from; they just ask for it from the context. This makes them more reusable.',
      },
      'state-management-libraries': {
        title: 'State Management Libraries (Redux, Zustand)',
        content:
          '### State Management Libraries (Redux, Zustand)\n\nWhen an application\'s state becomes complex and is needed by many components, passing props can become difficult. State management libraries provide a centralized store to hold the application\'s state, making it accessible from anywhere.\n\nWhile dozens of these libraries exist, the two most prominent approaches are represented by Redux and Zustand.\n\n---\n\n#### 1. Redux\n\nRedux has long been the most popular state management library for large-scale applications. It enforces a strict, predictable pattern for updating state.\n\n*   **Single Source of Truth:** The entire state of your application is stored in a single object tree called the "store."\n*   **Unidirectional Data Flow:** The flow of data is strict and follows a clear pattern:\n    *   **Action:** A plain object describing what happened (e.g., `{ type: \'ADD_TODO\', payload: \'Learn Redux\' }`).\n    *   **Dispatch:** An action is dispatched from a component to the store.\n    *   **Reducer:** A pure function takes the previous state and an action, and returns the next state.\n*   **Redux Toolkit (RTK):** Modern Redux is used with Redux Toolkit, which greatly simplifies the setup, reduces boilerplate, and includes powerful tools like `createSlice` to auto-generate actions and reducers.\n\n**When to use it:** Redux is ideal for large, complex enterprise applications where predictability, debugging (with time-travel), and a strict structure are critical.\n\n**Example (`createSlice` from Redux Toolkit):**\n```jsx\nimport { createSlice, configureStore } from \'@reduxjs/toolkit\';\n\nconst counterSlice = createSlice({\n  name: \'counter\',\n  initialState: { value: 0 },\n  reducers: {\n    increment: state => {\n      state.value += 1;\n    },\n    decrement: state => {\n      state.value -= 1;\n    },\n  },\n});\n\nexport const { increment, decrement } = counterSlice.actions;\n\nexport const store = configureStore({\n  reducer: {\n    counter: counterSlice.reducer,\n  },\n});\n```\n\n---\n\n#### 2. Zustand\n\nZustand is a small, fast, and scalable state management library that has surged in popularity due to its simplicity and minimal boilerplate. It uses a modern, hook-based API that feels more native to React.\n\n*   **Minimal API:** Create a store with a single function. There are no reducers, actions, or dispatchers to set up.\n*   **Hook-based:** Your store is a custom hook. You simply call this hook in any component to access and modify the state.\n*   **No Providers:** Unlike Context API or Redux, Zustand does not require you to wrap your application in a provider component.\n*   **Performance:** It automatically prevents unnecessary re-renders by letting components subscribe to specific slices of the state.\n\n**When to use it:** Zustand is an excellent choice for small to large applications, especially when developer experience and speed are priorities. It is often considered the versatile "sweet spot" for many modern projects.\n\n**Example:**\n```jsx\nimport { create } from \'zustand\';\n\n// 1. Create the store (which is a hook)\nconst useCounterStore = create((set) => ({\n  count: 0,\n  increment: () => set((state) => ({ count: state.count + 1 })),\n  decrement: () => set((state) => ({ count: state.count - 1 })),\n}));\n\n// 2. Use the hook in any component\nfunction Counter() {\n  const { count, increment, decrement } = useCounterStore();\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n    </div>\n  );\n}',
      },
    },
  },
  {
    title: 'Routing and Forms',
    topics: {
      'react-router': {
        title: 'React Router',
        content:
          '### React Router\n\nReact Router is the standard library for handling navigation in a React application. It allows you to build a single-page application (SPA) with multiple views or pages, managing the synchronization between the URL in the browser and the components being displayed.\n\nInstead of the browser making a new request to the server to fetch a new HTML page, React Router intercepts the navigation and dynamically renders the appropriate component for that URL without a full page refresh.\n\n---\n\n#### Core Components of React Router\n\nTo implement routing, you primarily work with four main components from the `react-router-dom` package.\n\n*   **`<BrowserRouter>`**\n    This component should wrap your entire application (or at least the part of it that needs routing). It uses the HTML5 History API to keep your UI in sync with the URL, allowing for clean URLs without a hash (`#`).\n    ```jsx\n    // In your index.js or App.js\n    import { BrowserRouter } from \'react-router-dom\';\n\n    ReactDOM.render(\n      <BrowserRouter>\n        <App />\n      </BrowserRouter>,\n      document.getElementById(\'root\')\n    );\n    ```\n\n*   **`<Routes>`**\n    This component acts as a container that holds all of your individual `<Route>` definitions. It intelligently looks through its children `<Route>` elements and renders the one whose path best matches the current URL.\n\n*   **`<Route>`**\n    This is the most important component. It maps a specific URL path to a React component. It has two main props:\n    *   `path`: A string that defines the URL path (e.g., `/about`, `/users/:id`).\n    *   `element`: The component that should be rendered when the URL matches the path.\n    ```jsx\n    import { Routes, Route } from \'react-router-dom\';\n    import Home from \'./pages/Home\';\n    import About from \'./pages/About\';\n\n    function App() {\n      return (\n        <Routes>\n          <Route path="/" element={<Home />} />\n          <Route path="/about" element={<About />} />\n        </Routes>\n      );\n    }\n    ```\n\n*   **`<Link>`**\n    This component is used to create navigation links. It is the equivalent of an HTML `<a>` tag, but it\'s aware of the router. When you click a `<Link>`, it prevents a full page reload and instead just updates the URL, allowing the `<Routes>` component to render the new page.\n    ```jsx\n    import { Link } from \'react-router-dom\';\n\n    function Navbar() {\n      return (\n        <nav>\n          <Link to="/">Home</Link>\n          <Link to="/about">About</Link>\n        </nav>\n      );\n    }\n    ```\nTogether, these components provide a declarative and powerful way to manage navigation and create a seamless user experience in a React application.',
      },
      'controlled-vs-uncontrolled': {
        title: 'Controlled vs. Uncontrolled Components',
        content:
          '### Controlled vs. Uncontrolled Components\n\nIn React, there are two main techniques for managing form inputs like `<input>`, `<textarea>`, and `<select>`: controlled components and uncontrolled components. The difference lies in where the data, or "state," of the form element is stored.\n\n---\n\n#### 1. Controlled Components\n\nA controlled component is an input element whose value is controlled by React state. This is the standard, recommended approach for handling forms in React.\n\n**How it works:**\n\n*   A state variable is created using `useState` to hold the value of the input.\n*   The input\'s `value` prop is set to this state variable.\n*   An `onChange` event handler is used to call the state\'s setter function, updating the state every time the user types.\n\nThis creates a "single source of truth." The React state and the input field are always in sync.\n\n**Example:**\n```jsx\nimport React, { useState } from \'react\';\n\nfunction ControlledForm() {\n  // 1. State is the source of truth\n  const [name, setName] = useState(\'\');\n\n  const handleChange = (event) => {\n    // 3. onChange updates the state\n    setName(event.target.value);\n  };\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    alert(`A name was submitted: ${name}`);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>Name:</label>\n      {/* 2. The input\'s value is tied to the state */}\n      <input type="text" value={name} onChange={handleChange} />\n      <button type="submit">Submit</button>\n    </form>\n  );\n}\n```\n\n**Pros:**\n\n*   The component has immediate access to the input\'s value.\n*   Allows for instant validation or formatting on every keystroke.\n*   Enables conditional logic (e.g., disabling a button if the input is empty).\n\n---\n\n#### 2. Uncontrolled Components\n\nAn uncontrolled component is an input element where the form data is handled by the DOM itself, just like in traditional HTML. React does not manage the input\'s value.\n\n**How it works:**\n\n*   Instead of using state, you use a `ref` (created with the `useRef` Hook) to get a direct reference to the DOM element.\n*   To get the input\'s value, you access `ref.current.value`, typically inside a submit handler.\n\n**Example:**\n```jsx\nimport React, { useRef } from \'react\';\n\nfunction UncontrolledForm() {\n  // 1. Create a ref to access the DOM element\n  const inputRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    // 2. Access the value directly from the DOM via the ref\n    alert(`A name was submitted: ${inputRef.current.value}`);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>Name:</label>\n      <input type="text" ref={inputRef} />\n      <button type="submit">Submit</button>\n    </form>\n  );\n}\n```\n\n**Pros:**\n\n*   Less code for simple forms where you only need the value on submission.\n*   Easier to integrate with non-React libraries that might manipulate the DOM.\n*   The `<input type="file" />` element is always uncontrolled.\n\n---\n\n#### Quick Comparison\n\n| Feature                 | Controlled Component | Uncontrolled Component          |\n| :---------------------- | :------------------- | :------------------------------ |\n| **Source of Truth**     | React State (`useState`) | The DOM                         |\n| **Get the Value**       | Value is always in the state variable | Pull the value from a ref when needed |\n| **Data Flow**           | State dictates the input\'s value | The DOM holds the value internally |\n| **Use Case**            | Most forms, complex validation | Simple forms, file inputs, legacy code |\n\n**Best Practice:**\nUse controlled components by default. They provide more control and fit better with the declarative nature of React. Uncontrolled components are a useful alternative for simpler scenarios or specific edge cases.',
      },
    },
  },
  {
    title: 'Advanced Concepts',
    topics: {
      'higher-order-components': {
        title: 'Higher-Order Components (HOCs)',
        content:
          '### Higher-Order Components (HOCs)\n\nA Higher-Order Component (HOC) is a function that takes a component as an argument and returns a new, enhanced component. It\'s an advanced React pattern for reusing component logic.\n\n> **Note:** HOCs are a powerful pattern, but they have been largely replaced in modern React by custom Hooks. Custom Hooks typically offer a simpler and more direct way to share logic. You will still encounter HOCs in older codebases and some libraries.\n\n---\n\n#### 1. How HOCs Work\n\nThe core idea is to wrap a component to give it extra functionality or props. Instead of modifying the original component, a HOC composes it by placing it inside a container. This allows you to inject logic without duplicating code.\n\nCommon use cases include:\n\n*   **Conditional rendering:** Showing a loader while data is fetching or checking if a user is authenticated.\n*   **Injecting props:** Providing data from a global source, like a theme or user information.\n*   **Abstracting state:** Managing shared stateful logic, such as toggling visibility.\n\n---\n\n#### 2. Creating a HOC\n\nA HOC is a function that follows this structure:\n`const enhancedComponent = higherOrderComponent(WrappedComponent);`\n\n**Example: A `withLoading` HOC**\nLet\'s create a HOC that displays a "Loading..." message until a component has its data.\n\n**Step 1: Create the HOC function.**\nThe `withLoading` function takes a component (`WrappedComponent`) as an argument and returns a new component. This new component checks for an `isLoading` prop. If true, it renders a loading message. Otherwise, it renders the `WrappedComponent` with all its original props.\n```jsx\n// withLoading.js\nfunction withLoading(WrappedComponent) {\n  return function ComponentWithLoading({ isLoading, ...props }) {\n    if (isLoading) {\n      return <p>Loading...</p>;\n    }\n    // Pass remaining props through to the original component\n    return <WrappedComponent {...props} />;\n  };\n}\n\nexport default withLoading;\n```\n\n**Step 2: Apply the HOC to a component.**\nNow, you can wrap any component that needs this loading logic.\n```jsx\nimport React from \'react\';\nimport withLoading from \'./withLoading\';\n\n// A simple component that displays a list of users\nfunction UserList({ users }) {\n  return (\n    <ul>\n      {users.map(user => <li key={user.id}>{user.name}</li>)}\n    </ul>\n  );\n}\n\n// Create the new, enhanced component by wrapping UserList with the HOC\nconst UserListWithLoading = withLoading(UserList);\n\nexport default UserListWithLoading;\n```\n\n**Step 3: Use the enhanced component.**\nIn your main app, you can use `UserListWithLoading`. The loading logic is handled by the HOC based on the `isLoading` prop you pass to it.\n```jsx\n// App.js\nimport React, { useState, useEffect } from \'react\';\nimport UserListWithLoading from \'./UserListWithLoading\';\n\nfunction App() {\n  const [loading, setLoading] = useState(true);\n  const [users, setUsers] = useState([]);\n\n  useEffect(() => {\n    // Simulate a data fetch\n    setTimeout(() => {\n      setUsers([{ id: 1, name: \'Alice\' }, { id: 2, name: \'Bob\' }]);\n      setLoading(false);\n    }, 2000);\n  }, []);\n\n  return (\n    <div>\n      <h1>User Dashboard</h1>\n      <UserListWithLoading isLoading={loading} users={users} />\n    </div>\n  );\n}\n```\nFor the first two seconds, the screen will show "Loading...". After that, the `UserList` will render with the fetched data. The `UserList` component itself remains simple and unaware of any loading logic.',
      },
      'render-props': {
        title: 'Render Props',
        content:
          '### Render Props\n\nA Render Prop is a technique for sharing code between React components using a prop whose value is a function. A component with a render prop doesn\'t implement its own rendering logic. Instead, it calls the function provided in its prop to know what to render.\n\nThis pattern inverts control: the component that has the state or logic (the container) delegates the rendering of its output to the component that uses it.\n\n> **Note:** Like HOCs, the Render Props pattern is now less common in modern React. Custom Hooks are generally a simpler and more direct way to achieve the same goal of logic reuse.\n\n---\n\n#### 1. How Render Props Work\n\nThe key idea is that one of your component\'s props is a function. This function takes arguments (usually state from the component) and returns JSX. The component\'s only job is to manage its internal state and then call this function with that state as arguments.\n\nThe prop doesn\'t have to be named `render`. Any prop that is a function and is used to render JSX is a render prop. A very common pattern is to use the `children` prop this way, which allows for a cleaner syntax.\n\n---\n\n#### 2. Example: A `MouseTracker` Component\n\nLet\'s build a component that tracks the mouse\'s X and Y coordinates and uses a render prop to display them. This allows the `MouseTracker` to be reused to render anything based on the mouse position.\n\n**Step 1: Create the component with a render prop.**\nThe `MouseTracker` component manages the state (`coords`) and the event listeners. Instead of rendering anything itself, it calls `this.props.render(this.state.coords)`, passing its state to the render function.\n```jsx\nimport React, { useState, useEffect } from \'react\';\n\nfunction MouseTracker({ render }) {\n  const [coords, setCoords] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handleMouseMove = (event) => {\n      setCoords({ x: event.clientX, y: event.clientY });\n    };\n\n    window.addEventListener(\'mousemove\', handleMouseMove);\n\n    return () => {\n      window.removeEventListener(\'mousemove\', handleMouseMove);\n    };\n  }, []);\n\n  // Call the render prop with the current state\n  return render(coords);\n}\n\nexport default MouseTracker;\n```\n\n**Step 2: Use the component.**\nNow, when you use `<MouseTracker>`, you provide a function as the `render` prop. This function receives the `coords` object and decides how to display it.\n```jsx\nimport React from \'react\';\nimport MouseTracker from \'./MouseTracker\';\n\nfunction App() {\n  return (\n    <div>\n      <h1>Move the mouse around!</h1>\n      <MouseTracker\n        render={(coords) => (\n          // This JSX is what gets rendered\n          <p>The mouse position is {coords.x}, {coords.y}</p>\n        )}\n      />\n\n      {/* Another use case for the same component */}\n      <MouseTracker\n        render={(coords) => (\n          <div style={{\n            height: \'20px\',\n            width: \'20px\',\n            background: \'blue\',\n            borderRadius: \'50%\',\n            position: \'absolute\',\n            left: coords.x,\n            top: coords.y,\n            transform: \'translate(-50%, -50%)\'\n          }} />\n        )}\n      />\n    </div>\n  );\n}\n```\nThis approach successfully separates the stateful logic (tracking the mouse) from the rendering logic (displaying coordinates or a blue dot), making the `MouseTracker` highly reusable.',
      },
      memoization: {
        title: 'Memoization (React.memo, useMemo, useCallback)',
        content:
          '### Memoization (`React.memo`, `useMemo`, `useCallback`)\n\nMemoization is a performance optimization technique used to speed up applications by caching the results of expensive function calls and returning the cached result when the same inputs occur again.\n\nIn React, re-rendering components is a normal process, but it can become slow if it happens too often or involves complex calculations. Memoization helps you prevent unnecessary re-renders and re-calculations. There are three main APIs for this: `React.memo`, `useMemo`, and `useCallback`.\n\n---\n\n#### 1. `React.memo`: Memoizing Components\n\n`React.memo` is a higher-order component (HOC) that prevents a functional component from re-rendering if its props have not changed.\n\n**How it works:** When a parent component re-renders, React will normally re-render all of its children. `React.memo` wraps around a child component and performs a shallow comparison of its current props and its next props. If they are the same, React skips re-rendering the component and reuses the last rendered result.\n\n**Use case:** Best for pure functional components that render the same output given the same props. It is especially useful for components in a list that might re-render when a sibling changes.\n\n**Example:**\nImagine a `User` component that receives a `name` prop. If the parent re-renders but the `name` prop stays the same, we don\'t need to re-render `User`.\n```jsx\nimport React from \'react\';\n\n// This component will only re-render if its \'name\' prop changes.\nconst User = React.memo(function User({ name }) {\n  console.log(`Rendering User: ${name}`);\n  return <p>Hello, {name}</p>;\n});\n\nexport default User;\n```\n\n---\n\n#### 2. `useMemo`: Memoizing Values\n\nThe `useMemo` Hook caches the result of a calculation between re-renders.\n\n**How it works:** You provide `useMemo` with a function that performs an expensive calculation and a dependency array. `useMemo` will only re-run the calculation if one of the dependencies has changed. Otherwise, it returns the cached value from the last render.\n\n**Use case:** Perfect for optimizing expensive computations, like filtering a large list or performing complex data transformations.\n\n**Example:**\nThis component filters a large list. Without `useMemo`, the filtering would happen on every single render, even if the `users` or `query` haven\'t changed.\n```jsx\nimport React, { useMemo } from \'react\';\n\nfunction UserList({ users, query }) {\n  // This expensive filtering only re-runs if \'users\' or \'query\' change.\n  const filteredUsers = useMemo(() => {\n    console.log(\'Filtering users...\');\n    return users.filter(user => user.name.includes(query));\n  }, [users, query]);\n\n  return (\n    <ul>\n      {filteredUsers.map(user => <li key={user.id}>{user.name}</li>)}\n    </ul>\n  );\n}\n```\n\n---\n\n#### 3. `useCallback`: Memoizing Functions\n\nThe `useCallback` Hook caches a function definition between re-renders.\n\n**How it works:** When a component re-renders, any functions defined inside it are re-created. This is usually fine, but if you pass that function as a prop to a child component wrapped in `React.memo`, the child will re-render because it sees a "new" function every time. `useCallback` returns the same function instance as long as its dependencies haven\'t changed.\n\n**Use case:** Primarily used to optimize child components that rely on referential equality (like `React.memo`). It ensures that prop functions don\'t trigger unnecessary re-renders in children.\n\n**Example:**\nHere, the `AnalyticsButton` is memoized. If we passed `handleClick` directly, it would be a new function on every render of `Dashboard`, causing `AnalyticsButton` to re-render. `useCallback` prevents this.\n```jsx\nimport React, { useState, useCallback } from \'react\';\n\nconst AnalyticsButton = React.memo(({ onClick }) => {\n  console.log("Rendering AnalyticsButton");\n  return <button onClick={onClick}>Send Analytics</button>;\n});\n\nfunction Dashboard() {\n  const [count, setCount] = useState(0);\n\n  // This function is now memoized and won\'t be recreated on every render.\n  const handleClick = useCallback(() => {\n    console.log("Sending analytics...");\n    // ...analytics logic\n  }, []); // Empty array means the function is created only once\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(c => c + 1)}>Increment</button>\n      <AnalyticsButton onClick={handleClick} />\n    </div>\n  );\n}\n',
      },
      'error-boundaries': {
        title: 'Error Boundaries',
        content:
          '### Error Boundaries\n\nAn Error Boundary is a special React component that catches JavaScript errors anywhere in its child component tree, logs those errors, and displays a fallback UI instead of the component tree that crashed.\n\nWithout an error boundary, a single JavaScript error in a part of the UI would break the entire React application, showing a white screen. Error boundaries allow you to gracefully handle these errors and keep the rest of your application interactive.\n\n---\n\n#### 1. How They Work\n\nError boundaries are class components that define one or both of the following lifecycle methods:\n\n*   `static getDerivedStateFromError(error)`: This method is called during the "render" phase after a descendant component throws an error. It should return an object to update the component\'s state, which allows you to trigger a fallback UI on the next render.\n*   `componentDidCatch(error, errorInfo)`: This method is called during the "commit" phase. It is used for side effects, like logging the error to an external service (e.g., Sentry, LogRocket).\n\n> **Important:** As of now, there is no Hook equivalent for error boundaries. You must use a class component to create one.\n\n---\n\n#### 2. Creating an Error Boundary\n\nHere is a typical example of an `ErrorBoundary` component.\n```jsx\nimport React from \'react\';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    // The state property \'hasError\' will determine which UI to render.\n    this.state = { hasError: false };\n  }\n\n  // 1. Update state so the next render will show the fallback UI.\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  // 2. Log the error to an error reporting service.\n  componentDidCatch(error, errorInfo) {\n    console.error("Uncaught error:", error, errorInfo);\n    // logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    // If an error was caught, render the fallback UI.\n    if (this.state.hasError) {\n      return <h1>Something went wrong. Please try again later.</h1>;\n    }\n\n    // Otherwise, render the children as normal.\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n```\n\n---\n\n#### 3. How to Use It\n\nYou simply wrap any part of your application that you want to protect. You can place it at the top level of your app or around specific, independent widgets.\n```jsx\nimport React from \'react\';\nimport ErrorBoundary from \'./ErrorBoundary\';\nimport BuggyComponent from \'./BuggyComponent\'; // A component that might throw an error\n\nfunction App() {\n  return (\n    <div>\n      <h1>My Application</h1>\n      <hr />\n      <ErrorBoundary>\n        <p>This content is inside the boundary.</p>\n        <BuggyComponent />\n      </ErrorBoundary>\n      <hr />\n      <p>This content is outside the boundary and will still render.</p>\n    </div>\n  );\n}\n```\nIf `BuggyComponent` throws an error, the "Something went wrong" message will be displayed in its place, but the "My Application" title and the content outside the boundary will remain visible and functional.\n\n---\n\n#### Limitations\n\nError boundaries do not catch errors in:\n\n*   Event handlers (use a `try...catch` block inside the handler).\n*   Asynchronous code (like `setTimeout` or `requestAnimationFrame` callbacks).\n*   Server-side rendering.\n*   The error boundary component itself.',
      },
      portals: {
        title: 'Portals',
        content:
          '### Portals\n\nReact Portals provide a first-class way to render a component into a DOM node that exists outside the direct parent-child hierarchy of the React component tree.\n\nNormally, a component\'s JSX is rendered as a child of its parent\'s DOM node. Portals allow a component to "break out" of its container, which is essential for UI elements that need to appear on top of everything else, like modals, tooltips, and notifications.\n\n---\n\n#### 1. Why Use Portals?\n\nThe primary use case for portals is to deal with CSS stacking context issues. If a parent component has a style like `overflow: hidden` or a specific `z-index`, it can clip or hide a child component that needs to be displayed on top of the entire page (like a modal dialog).\n\nBy rendering the modal\'s DOM structure to a separate element, such as `<div id="modal-root"></div>` placed directly under `<body>`, it is no longer constrained by its parent\'s styles.\n\n**Key benefits:**\n\n*   **Avoid CSS issues:** Bypasses parent overflow and z-index problems.\n*   **Semantic DOM:** Keeps your main app\'s DOM clean while placing pop-ups or modals in a more appropriate location at the top level.\n*   **Accessibility:** Helps with managing keyboard focus for elements like modals, as they are separate in the DOM.\n\n---\n\n#### 2. How to Use Portals\n\nUsing a portal involves two steps:\n\n1.  **Define a DOM container:** In your main `public/index.html` file, add a dedicated DOM node where the portal content will be rendered.\n    ```html\n    <body>\n      <noscript>You need to enable JavaScript to run this app.</noscript>\n      <div id="root"></div>\n      <!-- Portal container -->\n      <div id="modal-root"></div>\n    </body>\n    ```\n\n2.  **Use `ReactDOM.createPortal()`:** In your component, import `createPortal` from `react-dom`. This function takes two arguments:\n    *   `child`: The JSX you want to render.\n    *   `container`: The DOM element to render into (the one you created in step 1).\n\n**Syntax:**\n```jsx\nimport ReactDOM from \'react-dom\';\n\nReactDOM.createPortal(child, container);\n```\n\n**Example: A Simple Modal Component**\nThis `Modal` component renders its children into the `#modal-root` DOM node.\n```jsx\nimport React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport \'./Modal.css\'; // For styling the modal overlay and content\n\n// Get the portal container from the DOM\nconst modalRoot = document.getElementById(\'modal-root\');\n\nfunction Modal({ children }) {\n  // Use createPortal to render the children into the modalRoot container\n  return ReactDOM.createPortal(\n    <div className="modal-overlay">\n      <div className="modal-content">\n        {children}\n      </div>\n    </div>,\n    modalRoot\n  );\n}\n\nexport default Modal;\n```\n\n**Using the Modal:**\nNow, you can use the `<Modal>` component anywhere in your app. Even if it\'s nested deep inside other components, it will render at the top level of the DOM.\n```jsx\nimport React, { useState } from \'react\';\nimport Modal from \'./Modal\';\n\nfunction App() {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  return (\n    <div>\n      <h1>My App</h1>\n      <button onClick={() => setIsModalOpen(true)}>Open Modal</button>\n\n      {isModalOpen && (\n        <Modal>\n          <h2>This is a Modal</h2>\n          <p>It is rendered outside the main root div!</p>\n          <button onClick={() => setIsModalOpen(false)}>Close</button>\n        </Modal>\n      )}\n    </div>\n  );\n}\n```\nEven though the portal\'s content is in a different place in the DOM tree, it still exists as a normal child in the React component tree. This means it can still receive props and context, and events will bubble up to its parent components as expected.',
      },
      'lazy-loading-code-splitting': {
        title: 'Lazy Loading and Code Splitting',
        content:
          '### Lazy Loading and Code Splitting\n\nAs a React application grows, its JavaScript bundle size can become very large. This can significantly slow down the initial load time. Code splitting is the technique of breaking up your application\'s large bundle into smaller chunks that can be loaded on demand. Lazy loading is the practice of loading these chunks only when they are actually needed.\n\nThis dramatically improves performance because the user only downloads the code necessary for the initial page, rather than the entire application.\n\n---\n\n#### 1. How It Works: `React.lazy` and `Suspense`\n\nReact provides two core features that make code splitting and lazy loading straightforward:\n\n*   `React.lazy()`: A function that lets you render a dynamic import as a regular component. It takes a function that must call a dynamic `import()`. This returns a Promise that resolves to a module with a default export containing a React component.\n*   `<Suspense>`: A component that lets you specify a "fallback" UI (like a loading spinner) to show while the lazy-loaded component\'s code is being fetched and loaded.\n\nTogether, they allow you to load components only when they are about to be rendered.\n\n---\n\n#### 2. Route-Based Code Splitting\n\nThe most common and effective way to implement code splitting is on a per-route basis. This means each page or major section of your application becomes its own JavaScript chunk, and it\'s only loaded when the user navigates to that route.\n\n**Example:**\nImagine an application with a Home page and an About page. The code for the About page is not needed when the user first visits the homepage.\n\n**Step 1: Convert static imports to dynamic imports with `React.lazy`**\n```jsx\nimport React, { Suspense } from \'react\';\nimport { BrowserRouter as Router, Routes, Route, Link } from \'react-router-dom\';\n\n// Static import (loads immediately in the main bundle)\n// import About from \'./pages/About\'; \n\n// Dynamic import with React.lazy\nconst Home = React.lazy(() => import(\'./pages/Home\'));\nconst About = React.lazy(() => import(\'./pages/About\'));\n```\n> **Note:** `React.lazy` currently only supports default exports.\n\n**Step 2: Wrap your routes with the `<Suspense>` component**\nThe `Suspense` component must be placed somewhere above the lazy-loaded component in the tree. It will catch the "suspense" of any lazy component trying to render and will display the fallback UI until the code is ready.\n```jsx\nfunction App() {\n  return (\n    <Router>\n      <nav>\n        <Link to="/">Home</Link>\n        <Link to="/about">About</Link>\n      </nav>\n\n      {/* Suspense shows a loading message while the lazy component is fetched */}\n      <Suspense fallback={<div>Loading page...</div>}>\n        <Routes>\n          <Route path="/" element={<Home />} />\n          <Route path="/about" element={<About />} />\n        </Routes>\n      </Suspense>\n    </Router>\n  );\n}\n```\n\n**Result:**\n\n*   When a user first loads the application, only the code for the Home page is downloaded.\n*   When they click the "About" link, React will fetch the JavaScript chunk for the About page.\n*   While the About page chunk is loading, the user will see the "Loading page..." message. Once loaded, the About component will render.',
      },
    },
  },
];
